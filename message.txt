  '/messages/:id',
  [
    param('id').isUUID().withMessage('Message ID must be a valid UUID'),
    body('content')
      .optional()
      .isLength({ min: 1, max: 4000 })
      .withMessage('Content must be between 1 and 4000 characters'),
    body('media_url')
      .optional()
      .isURL()
      .withMessage('Media URL must be valid')
  ],
  chatController.updateMessage
);

/**
 * DELETE /api/chat/messages/:id - Supprimer un message
 */
router.delete(
  '/messages/:id',
  [
    param('id').isUUID().withMessage('Message ID must be a valid UUID')
  ],
  chatController.deleteMessage
);

/**
 * POST /api/chat/messages/:id/react - R√©agir √† un message
 */
router.post(
  '/messages/:id/react',
  [
    param('id').isUUID().withMessage('Message ID must be a valid UUID'),
    body('emoji')
      .isLength({ min: 1, max: 10 })
      .withMessage('Emoji is required and must be valid'),
    body('action')
      .optional()
      .isIn(['add', 'remove'])
      .withMessage('Action must be "add" or "remove"')
  ],
  chatController.reactToMessage
);

// ============ ROUTES LECTURES ============

/**
 * POST /api/chat/conversations/:id/read - Marquer les messages comme lus
 */
router.post(
  '/conversations/:id/read',
  [
    param('id').isUUID().withMessage('Conversation ID must be a valid UUID'),
    body('last_message_id')
      .isUUID()
      .withMessage('Last message ID must be a valid UUID')
  ],
  chatController.markAsRead
);

/**
 * GET /api/chat/conversations/:id/unread-count - Compter les messages non lus
 */
router.get(
  '/conversations/:id/unread-count',
  [
    param('id').isUUID().withMessage('Conversation ID must be a valid UUID')
  ],
  chatController.getUnreadCount
);

// ============ ROUTES STATISTIQUES ============

/**
 * GET /api/chat/stats - Statistiques globales du chat
 */
router.get('/stats', chatController.getChatStats);

export default router;// backend/src/modules/chat/chat.service.ts
// =============================================
// SERVICE BACKEND - Chat Syst√®me Temps R√©el avec NOUVEAU PATTERN RLS
// =============================================

import { supabaseAdmin } from '../../config/database';

// Types pour le chat
export interface Conversation {
  id: string;
  participant_1_id: string;
  participant_2_id: string;
  created_at: string;
  last_message_at: string;
  last_message_id: string | null;
  status: 'active' | 'archived' | 'blocked';
  other_participant?: {
    id: string;
    name: string;
    avatar_url: string | null;
  };
  unread_count?: number;
  last_message?: Message;
}

export interface Message {
  id: string;
  conversation_id: string;
  sender_id: string;
  content: string | null;
  message_type: 'text' | 'image' | 'voice' | 'system';
  media_url: string | null;
  media_metadata: any;
  reply_to_id: string | null;
  reactions: Record<string, string[]>;
  expires_at: string | null;
  edited_at: string | null;
  deleted_at: string | null;
  created_at: string;
  updated_at: string;
  sender?: {
    id: string;
    name: string;
    avatar_url: string | null;
  };
  reply_to?: Message;
}

export interface MessageRead {
  id: string;
  conversation_id: string;
  user_id: string;
  last_read_message_id: string | null;
  read_at: string;
}

// Interfaces pour les param√®tres
export interface CreateConversationParams {
  participant_1_id: string;
  participant_2_id: string;
}

export interface SendMessageParams {
  conversation_id: string;
  sender_id: string;
  content?: string;
  message_type?: 'text' | 'image' | 'voice' | 'system';
  media_url?: string;
  media_metadata?: any;
  reply_to_id?: string;
  expires_in_minutes?: number;
}

export interface UpdateMessageParams {
  message_id: string;
  user_id: string;
  content?: string;
  media_url?: string;
  media_metadata?: any;
}

export interface ReactToMessageParams {
  message_id: string;
  user_id: string;
  emoji: string;
  action: 'add' | 'remove';
}

class ChatService {
  private webSocketService?: any;

  setWebSocketService(webSocketService: any) {
    this.webSocketService = webSocketService;
  }

  // ============ GESTION DES CONVERSATIONS ============

  /**
   * ‚úÖ GARDE ADMIN - Cr√©er une nouvelle conversation (syst√®me apr√®s miroir accept√©)
   */
  async createConversation(params: CreateConversationParams): Promise<Conversation> {
    try {
      console.log('üí¨ Chat Service - Cr√©ation conversation:', params);

      // V√©rifier qu'une conversation n'existe pas d√©j√† entre ces utilisateurs
      const existingConversation = await this.findExistingConversation(
        params.participant_1_id,
        params.participant_2_id
      );

      if (existingConversation) {
        console.log('‚úÖ Conversation existante trouv√©e:', existingConversation.id);
        return existingConversation;
      }

      // Cr√©er la nouvelle conversation avec supabaseAdmin (syst√®me)
      const { data: newConversation, error } = await supabaseAdmin
        .from('conversations')
        .insert({
          participant_1_id: params.participant_1_id,
          participant_2_id: params.participant_2_id,
          created_at: new Date().toISOString(),
          last_message_at: new Date().toISOString()
        })
        .select()
        .single();

      if (error) {
        console.error('‚ùå Erreur cr√©ation conversation:', error);
        throw error;
      }

      console.log('‚úÖ Conversation cr√©√©e:', newConversation.id);

      // Envoyer un message syst√®me de bienvenue avec supabaseAdmin
      await this.sendSystemMessage({
        conversation_id: newConversation.id,
        sender_id: 'system',
        content: 'üéâ F√©licitations ! Vous pouvez maintenant discuter suite √† l\'acceptation du contact.',
        message_type: 'system'
      });

      // Cr√©er une notification pour les deux participants
      await this.notifyNewConversation(newConversation);

      return newConversation;

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur createConversation:', error);
      throw error;
    }
  }

  /**
   * ‚úÖ GARDE ADMIN - Chercher une conversation existante entre deux utilisateurs (syst√®me)
   */
  async findExistingConversation(userId1: string, userId2: string): Promise<Conversation | null> {
    try {
      const { data, error } = await supabaseAdmin
        .from('conversations')
        .select('*')
        .or(`and(participant_1_id.eq.${userId1},participant_2_id.eq.${userId2}),and(participant_1_id.eq.${userId2},participant_2_id.eq.${userId1})`)
        .single();

      if (error && error.code !== 'PGRST116') {
        throw error;
      }

      return data || null;
    } catch (error) {
      console.error('‚ùå Erreur findExistingConversation:', error);
      return null;
    }
  }

  /**
   * ‚úÖ CORRIG√â - R√©cup√©rer les conversations d'un utilisateur avec NOUVEAU PATTERN RLS
   */
  async getUserConversations(userId: string, userToken: string, limit: number = 20, offset: number = 0): Promise<Conversation[]> {
    try {
      console.log('üìù Chat Service - R√©cup√©ration conversations pour:', userId);

      // ‚úÖ Validation token
      const { data: { user }, error: tokenError } = await supabaseAdmin.auth.getUser(userToken);
      if (tokenError || !user || user.id !== userId) {
        throw new Error('Unauthorized');
      }

      // R√©cup√©rer les conversations avec supabaseAdmin + WHERE explicites
      const { data: conversations, error } = await supabaseAdmin
        .from('conversations')
        .select(`
          id,
          participant_1_id,
          participant_2_id,
          created_at,
          last_message_at,
          last_message_id,
          status
        `)
        .or(`participant_1_id.eq.${userId},participant_2_id.eq.${userId}`)
        .order('last_message_at', { ascending: false })
        .range(offset, offset + limit - 1);

      if (error) {
        console.error('‚ùå Erreur r√©cup√©ration conversations:', error);
        throw error;
      }

      if (!conversations || conversations.length === 0) {
        return [];
      }

      // Enrichir avec les donn√©es des autres participants
      const enrichedConversations = await Promise.all(
        conversations.map(async (conv) => {
          const otherUserId = conv.participant_1_id === userId
            ? conv.participant_2_id
            : conv.participant_1_id;

          // R√©cup√©rer les infos de l'autre participant avec supabaseAdmin (infos publiques)
          const { data: otherUser } = await supabaseAdmin
            .from('profiles')
            .select('id, name, avatar_url')
            .eq('id', otherUserId)
            .single();

          // R√©cup√©rer le dernier message
          let lastMessage = null;
          if (conv.last_message_id) {
            const { data: messageData } = await supabaseAdmin
              .from('messages')
              .select('id, content, message_type, created_at, sender_id')
              .eq('id', conv.last_message_id)
              .eq('conversation_id', conv.id)
              .single();
            lastMessage = messageData;
          }

          // Compter les messages non lus
          const unreadCount = await this.getUnreadMessagesCount(conv.id, userId, userToken);

          return {
            ...conv,
            other_participant: otherUser ? {
              id: otherUser.id,
              name: otherUser.name || 'Utilisateur',
              avatar_url: otherUser.avatar_url
            } : null,
            unread_count: unreadCount,
            last_message: lastMessage
          };
        })
      );

      console.log(`‚úÖ ${enrichedConversations.length} conversations r√©cup√©r√©es`);
      return enrichedConversations;

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur getUserConversations:', error);
      throw error;
    }
  }

  /**
   * ‚úÖ CORRIG√â - R√©cup√©rer une conversation sp√©cifique avec NOUVEAU PATTERN RLS
   */
  async getConversation(conversationId: string, userId: string, userToken: string): Promise<Conversation | null> {
    try {
      // ‚úÖ Validation token
      const { data: { user }, error: tokenError } = await supabaseAdmin.auth.getUser(userToken);
      if (tokenError || !user || user.id !== userId) {
        throw new Error('Unauthorized');
      }

      const { data: conversation, error } = await supabaseAdmin
        .from('conversations')
        .select('*')
        .eq('id', conversationId)
        .or(`participant_1_id.eq.${userId},participant_2_id.eq.${userId}`)
        .single();

      if (error || !conversation) {
        return null;
      }

      // Enrichir avec les donn√©es de l'autre participant
      const otherUserId = conversation.participant_1_id === userId
        ? conversation.participant_2_id
        : conversation.participant_1_id;

      const { data: otherUser } = await supabaseAdmin
        .from('profiles')
        .select('id, name, avatar_url')
        .eq('id', otherUserId)
        .single();

      return {
        ...conversation,
        other_participant: otherUser ? {
          id: otherUser.id,
          name: otherUser.name || 'Utilisateur',
          avatar_url: otherUser.avatar_url
        } : null
      };

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur getConversation:', error);
      throw error;
    }
  }

  // ============ GESTION DES MESSAGES ============

  /**
   * ‚úÖ CORRIG√â - Envoyer un message avec NOUVEAU PATTERN RLS
   */
  async sendMessage(params: SendMessageParams, userToken: string): Promise<Message> {
    try {
      console.log('üì§ Chat Service - Envoi message:', params);

      // ‚úÖ Validation token
      const { data: { user }, error: tokenError } = await supabaseAdmin.auth.getUser(userToken);
      if (tokenError || !user || user.id !== params.sender_id) {
        throw new Error('Unauthorized');
      }

      // V√©rifier que l'utilisateur a acc√®s √† cette conversation
      const conversation = await this.getConversation(params.conversation_id, params.sender_id, userToken);
      if (!conversation) {
        throw new Error('Conversation not found or access denied');
      }

      // Calculer la date d'expiration si message √©ph√©m√®re
      let expiresAt = null;
      if (params.expires_in_minutes) {
        expiresAt = new Date();
        expiresAt.setMinutes(expiresAt.getMinutes() + params.expires_in_minutes);
      }

      // Ins√©rer le message avec supabaseAdmin
      const { data: newMessage, error } = await supabaseAdmin
        .from('messages')
        .insert({
          conversation_id: params.conversation_id,
          sender_id: params.sender_id,
          content: params.content || null,
          message_type: params.message_type || 'text',
          media_url: params.media_url || null,
          media_metadata: params.media_metadata || null,
          reply_to_id: params.reply_to_id || null,
          expires_at: expiresAt?.toISOString() || null,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        })
        .select()
        .single();

      if (error) {
        console.error('‚ùå Erreur envoi message:', error);
        throw error;
      }

      // Mettre √† jour le last_message_at de la conversation
      await supabaseAdmin
        .from('conversations')
        .update({
          last_message_at: new Date().toISOString(),
          last_message_id: newMessage.id
        })
        .eq('id', params.conversation_id);

      console.log('‚úÖ Message envoy√©:', newMessage.id);

      // R√©cup√©rer le message enrichi
      const enrichedMessage = await this.getMessageWithDetails(newMessage.id, userToken);

      // Notifier les participants via WebSocket
      await this.notifyNewMessage(enrichedMessage);

      return enrichedMessage;

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur sendMessage:', error);
      throw error;
    }
  }

  /**
   * ‚úÖ GARDE ADMIN - Envoyer un message syst√®me (sans RLS)
   */
  private async sendSystemMessage(params: SendMessageParams): Promise<Message> {
    try {
      // Calculer la date d'expiration si message √©ph√©m√®re
      let expiresAt = null;
      if (params.expires_in_minutes) {
        expiresAt = new Date();
        expiresAt.setMinutes(expiresAt.getMinutes() + params.expires_in_minutes);
      }

      // Ins√©rer le message syst√®me avec supabaseAdmin
      const { data: newMessage, error } = await supabaseAdmin
        .from('messages')
        .insert({
          conversation_id: params.conversation_id,
          sender_id: params.sender_id,
          content: params.content || null,
          message_type: params.message_type || 'system',
          media_url: params.media_url || null,
          media_metadata: params.media_metadata || null,
          reply_to_id: params.reply_to_id || null,
          expires_at: expiresAt?.toISOString() || null,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        })
        .select()
        .single();

      if (error) {
        console.error('‚ùå Erreur envoi message syst√®me:', error);
        throw error;
      }

      // Mettre √† jour le last_message_at de la conversation
      await supabaseAdmin
        .from('conversations')
        .update({
          last_message_at: new Date().toISOString(),
          last_message_id: newMessage.id
        })
        .eq('id', params.conversation_id);

      console.log('‚úÖ Message syst√®me envoy√©:', newMessage.id);
      return newMessage;

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur sendSystemMessage:', error);
      throw error;
    }
  }

  /**
   * ‚úÖ CORRIG√â - R√©cup√©rer les messages d'une conversation avec NOUVEAU PATTERN RLS
   */
  async getConversationMessages(
    conversationId: string,
    userId: string,
    userToken: string,
    limit: number = 50,
    offset: number = 0
  ): Promise<Message[]> {
    try {
      console.log('üìã Chat Service - R√©cup√©ration messages conversation:', conversationId);

      // ‚úÖ Validation token
      const { data: { user }, error: tokenError } = await supabaseAdmin.auth.getUser(userToken);
      if (tokenError || !user || user.id !== userId) {
        throw new Error('Unauthorized');
      }

      // V√©rifier que l'utilisateur a acc√®s √† cette conversation
      const conversation = await this.getConversation(conversationId, userId, userToken);
      if (!conversation) {
        throw new Error('Conversation not found or access denied');
      }

      // R√©cup√©rer les messages avec supabaseAdmin
      const { data: messages, error } = await supabaseAdmin
        .from('messages')
        .select(`
          id,
          conversation_id,
          sender_id,
          content,
          message_type,
          media_url,
          media_metadata,
          reply_to_id,
          reactions,
          expires_at,
          edited_at,
          deleted_at,
          created_at,
          updated_at
        `)
        .eq('conversation_id', conversationId)
        .is('deleted_at', null)
        .order('created_at', { ascending: false })
        .range(offset, offset + limit - 1);

      if (error) {
        console.error('‚ùå Erreur r√©cup√©ration messages:', error);
        throw error;
      }

      if (!messages || messages.length === 0) {
        return [];
      }

      // Enrichir les messages avec les donn√©es des senders
      const enrichedMessages = await Promise.all(
        messages.map(async (message) => {
          // R√©cup√©rer les infos du sender (sauf pour les messages syst√®me)
          let sender = null;
          if (message.sender_id !== 'system') {
            const { data: senderData } = await supabaseAdmin
              .from('profiles')
              .select('id, name, avatar_url')
              .eq('id', message.sender_id)
              .single();

            sender = senderData ? {
              id: senderData.id,
              name: senderData.name || 'Utilisateur',
              avatar_url: senderData.avatar_url
            } : null;
          }

          // R√©cup√©rer le message de r√©ponse si applicable
          let replyTo = null;
          if (message.reply_to_id) {
            try {
              replyTo = await this.getMessageWithDetails(message.reply_to_id, userToken);
            } catch (e) {
              // Message de r√©ponse non accessible, continuer
            }
          }

          return {
            ...message,
            sender,
            reply_to: replyTo
          };
        })
      );

      console.log(`‚úÖ ${enrichedMessages.length} messages r√©cup√©r√©s`);
      return enrichedMessages.reverse(); // Plus ancien en premier

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur getConversationMessages:', error);
      throw error;
    }
  }

  /**
   * ‚úÖ CORRIG√â - Modifier un message avec NOUVEAU PATTERN RLS
   */
  async updateMessage(params: UpdateMessageParams, userToken: string): Promise<Message> {
    try {
      console.log('‚úèÔ∏è Chat Service - Modification message:', params.message_id);

      // ‚úÖ Validation token
      const { data: { user }, error: tokenError } = await supabaseAdmin.auth.getUser(userToken);
      if (tokenError || !user || user.id !== params.user_id) {
        throw new Error('Unauthorized');
      }

      // V√©rifier que l'utilisateur est le propri√©taire du message
      const { data: existingMessage } = await supabaseAdmin
        .from('messages')
        .select('sender_id, conversation_id')
        .eq('id', params.message_id)
        .eq('sender_id', params.user_id)
        .single();

      if (!existingMessage) {
        throw new Error('Message not found or access denied');
      }

      // Mettre √† jour le message avec supabaseAdmin
      const { data: updatedMessage, error } = await supabaseAdmin
        .from('messages')
        .update({
          content: params.content,
          media_url: params.media_url,
          media_metadata: params.media_metadata,
          edited_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        })
        .eq('id', params.message_id)
        .eq('sender_id', params.user_id)
        .select()
        .single();

      if (error) {
        console.error('‚ùå Erreur modification message:', error);
        throw error;
      }

      // R√©cup√©rer le message enrichi
      const enrichedMessage = await this.getMessageWithDetails(updatedMessage.id, userToken);

      // Notifier la modification via WebSocket
      await this.notifyMessageUpdated(enrichedMessage);

      return enrichedMessage;

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur updateMessage:', error);
      throw error;
    }
  }

  /**
   * ‚úÖ CORRIG√â - Supprimer un message avec NOUVEAU PATTERN RLS
   */
  async deleteMessage(messageId: string, userId: string, userToken: string): Promise<boolean> {
    try {
      console.log('üóëÔ∏è Chat Service - Suppression message:', messageId);

      // ‚úÖ Validation token
      const { data: { user }, error: tokenError } = await supabaseAdmin.auth.getUser(userToken);
      if (tokenError || !user || user.id !== userId) {
        throw new Error('Unauthorized');
      }

      // V√©rifier que l'utilisateur est le propri√©taire du message
      const { data: existingMessage } = await supabaseAdmin
        .from('messages')
        .select('sender_id')
        .eq('id', messageId)
        .eq('sender_id', userId)
        .single();

      if (!existingMessage) {
        throw new Error('Message not found or access denied');
      }

      // Soft delete avec supabaseAdmin
      const { error } = await supabaseAdmin
        .from('messages')
        .update({
          deleted_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        })
        .eq('id', messageId)
        .eq('sender_id', userId);

      if (error) {
        console.error('‚ùå Erreur suppression message:', error);
        throw error;
      }

      // Notifier la suppression via WebSocket
      await this.notifyMessageDeleted(messageId);

      return true;

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur deleteMessage:', error);
      throw error;
    }
  }

  /**
   * ‚úÖ CORRIG√â - R√©agir √† un message avec NOUVEAU PATTERN RLS
   */
  async reactToMessage(params: ReactToMessageParams, userToken: string): Promise<Message> {
    try {
      console.log('üòä Chat Service - R√©action message:', params);

      // ‚úÖ Validation token
      const { data: { user }, error: tokenError } = await supabaseAdmin.auth.getUser(userToken);
      if (tokenError || !user || user.id !== params.user_id) {
        throw new Error('Unauthorized');
      }

      // R√©cup√©rer le message existant
      const { data: message, error } = await supabaseAdmin
        .from('messages')
        .select('reactions, conversation_id')
        .eq('id', params.message_id)
        .single();

      if (error || !message) {
        throw new Error('Message not found');
      }

      // V√©rifier acc√®s √† la conversation
      const conversation = await this.getConversation(message.conversation_id, params.user_id, userToken);
      if (!conversation) {
        throw new Error('Access denied to conversation');
      }

      // Modifier les r√©actions
      const reactions = message.reactions || {};
      const emoji = params.emoji;
      const userId = params.user_id;

      if (params.action === 'add') {
        if (!reactions[emoji]) {
          reactions[emoji] = [];
        }
        if (!reactions[emoji].includes(userId)) {
          reactions[emoji].push(userId);
        }
      } else {
        if (reactions[emoji]) {
          reactions[emoji] = reactions[emoji].filter(id => id !== userId);
          if (reactions[emoji].length === 0) {
            delete reactions[emoji];
          }
        }
      }

      // Mettre √† jour en base avec supabaseAdmin
      const { data: updatedMessage, error: updateError } = await supabaseAdmin
        .from('messages')
        .update({
          reactions: reactions,
          updated_at: new Date().toISOString()
        })
        .eq('id', params.message_id)
        .select()
        .single();

      if (updateError) {
        throw updateError;
      }

      // R√©cup√©rer le message enrichi
      const enrichedMessage = await this.getMessageWithDetails(updatedMessage.id, userToken);

      // Notifier via WebSocket
      await this.notifyMessageReaction(enrichedMessage, params.emoji, params.action);

      return enrichedMessage;

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur reactToMessage:', error);
      throw error;
    }
  }

  // ============ GESTION DES LECTURES ============

  /**
   * ‚úÖ CORRIG√â - Marquer les messages comme lus avec NOUVEAU PATTERN RLS
   */
  async markMessagesAsRead(conversationId: string, userId: string, lastMessageId: string, userToken: string): Promise<void> {
    try {
      console.log('‚úÖ Chat Service - Marquage lu:', { conversationId, userId, lastMessageId });

      // ‚úÖ Validation token
      const { data: { user }, error: tokenError } = await supabaseAdmin.auth.getUser(userToken);
      if (tokenError || !user || user.id !== userId) {
        throw new Error('Unauthorized');
      }

      // V√©rifier acc√®s √† la conversation
      const conversation = await this.getConversation(conversationId, userId, userToken);
      if (!conversation) {
        throw new Error('Access denied to conversation');
      }

      // Upsert du marqueur de lecture avec supabaseAdmin
      const { error } = await supabaseAdmin
        .from('message_reads')
        .upsert({
          conversation_id: conversationId,
          user_id: userId,
          last_read_message_id: lastMessageId,
          read_at: new Date().toISOString()
        }, {
          onConflict: 'conversation_id,user_id'
        });

      if (error) {
        console.error('‚ùå Erreur marquage lu:', error);
        throw error;
      }

      // Notifier via WebSocket que les messages ont √©t√© lus
      await this.notifyMessagesRead(conversationId, userId, lastMessageId);

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur markMessagesAsRead:', error);
      throw error;
    }
  }

  /**
   * ‚úÖ CORRIG√â - Compter les messages non lus avec NOUVEAU PATTERN RLS
   */
  async getUnreadMessagesCount(conversationId: string, userId: string, userToken: string): Promise<number> {
    try {
      // ‚úÖ Validation token
      const { data: { user }, error: tokenError } = await supabaseAdmin.auth.getUser(userToken);
      if (tokenError || !user || user.id !== userId) {
        return 0;
      }

      // R√©cup√©rer le dernier message lu
      const { data: lastRead } = await supabaseAdmin
        .from('message_reads')
        .select('last_read_message_id')
        .eq('conversation_id', conversationId)
        .eq('user_id', userId)
        .single();

      if (!lastRead || !lastRead.last_read_message_id) {
        // Compter tous les messages non supprim√©s dans la conversation (pas de l'utilisateur)
        const { count } = await supabaseAdmin
          .from('messages')
          .select('*', { count: 'exact', head: true })
          .eq('conversation_id', conversationId)
          .neq('sender_id', userId)
          .is('deleted_at', null);

        return count || 0;
      }

      // Compter les messages apr√®s le dernier lu
      const { data: lastReadMessage } = await supabaseAdmin
        .from('messages')
        .select('created_at')
        .eq('id', lastRead.last_read_message_id)
        .single();

      if (!lastReadMessage) return 0;

      const { count } = await supabaseAdmin
        .from('messages')
        .select('*', { count: 'exact', head: true })
        .eq('conversation_id', conversationId)
        .neq('sender_id', userId)
        .gt('created_at', lastReadMessage.created_at)
        .is('deleted_at', null);

      return count || 0;

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur getUnreadMessagesCount:', error);
      return 0;
    }
  }

  /**
   * ‚úÖ CORRIG√â - R√©cup√©rer le nombre total de conversations non lues avec NOUVEAU PATTERN RLS
   */
  async getTotalUnreadConversationsCount(userId: string, userToken: string): Promise<number> {
    try {
      const conversations = await this.getUserConversations(userId, userToken, 100, 0);
      return conversations.filter(conv => (conv.unread_count || 0) > 0).length;
    } catch (error) {
      console.error('‚ùå Chat Service - Erreur getTotalUnreadConversationsCount:', error);
      return 0;
    }
  }

  // ============ INT√âGRATION AVEC LE SYST√àME DE MIROIR ============

  /**
   * ‚úÖ GARDE ADMIN - Cr√©er automatiquement une conversation apr√®s acceptation d'un contact
   */
  async createConversationFromMirrorAcceptance(senderId: string, receiverId: string): Promise<Conversation> {
    try {
      console.log('ü™û‚û°Ô∏èüí¨ Cr√©ation conversation depuis contact accept√©:', { senderId, receiverId });

      // Cr√©er la conversation (utilise supabaseAdmin car syst√®me)
      const conversation = await this.createConversation({
        participant_1_id: senderId,
        participant_2_id: receiverId
      });

      // Cr√©er une notification sp√©ciale pour les deux utilisateurs
      await this.createChatNotification(senderId, receiverId, conversation.id);
      await this.createChatNotification(receiverId, senderId, conversation.id);

      return conversation;

    } catch (error) {
      console.error('‚ùå Erreur createConversationFromMirrorAcceptance:', error);
      throw error;
    }
  }

  // ============ M√âTHODES PRIV√âES ============

  /**
   * ‚úÖ CORRIG√â - R√©cup√©rer un message avec tous ses d√©tails avec NOUVEAU PATTERN RLS
   */
  private async getMessageWithDetails(messageId: string, userToken: string): Promise<Message> {
    // ‚úÖ Validation token
    const { data: { user }, error: tokenError } = await supabaseAdmin.auth.getUser(userToken);
    if (tokenError || !user) {
      throw new Error('Unauthorized');
    }

    const { data: message, error } = await supabaseAdmin
      .from('messages')
      .select('*')
      .eq('id', messageId)
      .single();

    if (error || !message) {
      throw new Error('Message not found');
    }

    // Enrichir avec les donn√©es du sender (sauf pour les messages syst√®me)
    let sender = null;
    if (message.sender_id !== 'system') {
      const { data: senderData } = await supabaseAdmin
        .from('profiles')
        .select('id, name, avatar_url')
        .eq('id', message.sender_id)
        .single();

      sender = senderData ? {
        id: senderData.id,
        name: senderData.name || 'Utilisateur',
        avatar_url: senderData.avatar_url
      } : null;
    }

    return {
      ...message,
      sender
    };
  }

  /**
   * Notifier une nouvelle conversation
   */
  private async notifyNewConversation(conversation: Conversation): Promise<void> {
    console.log('üîî Notification nouvelle conversation:', conversation.id);

    if (this.webSocketService) {
      this.webSocketService.notifyNewConversation([
        conversation.participant_1_id,
        conversation.participant_2_id
      ], conversation);
    }
  }

  /**
   * Notifier un nouveau message
   */
  private async notifyNewMessage(message: Message): Promise<void> {
    console.log('üîî Notification nouveau message:', message.id);

    if (this.webSocketService) {
      this.webSocketService.notifyNewMessage(
        message.conversation_id,
        message,
        message.sender_id
      );
    }
  }

  /**
   * Notifier la modification d'un message
   */
  private async notifyMessageUpdated(message: Message): Promise<void> {
    console.log('üîî Notification message modifi√©:', message.id);

    if (this.webSocketService) {
      this.webSocketService.notifyMessageUpdate(message.conversation_id, message);
    }
  }

  /**
   * Notifier la suppression d'un message
   */
  private async notifyMessageDeleted(messageId: string): Promise<void> {
    console.log('üîî Notification message supprim√©:', messageId);

    // R√©cup√©rer l'info de la conversation depuis le message
    const { data: message } = await supabaseAdmin
      .from('messages')
      .select('conversation_id')
      .eq('id', messageId)
      .single();

    if (this.webSocketService && message) {
      this.webSocketService.notifyMessageDeleted(message.conversation_id, messageId);
    }
  }

  /**
   * Notifier une r√©action
   */
  private async notifyMessageReaction(message: Message, emoji: string, action: 'add' | 'remove'): Promise<void> {
    console.log('üîî Notification r√©action:', { messageId: message.id, emoji, action });

    if (this.webSocketService) {
      this.webSocketService.notifyMessageReaction(
        message.conversation_id,
        message.id,
        emoji,
        action,
        message.sender_id
      );
    }
  }

  /**
   * Notifier que des messages ont √©t√© lus
   */
  private async notifyMessagesRead(conversationId: string, userId: string, lastMessageId: string): Promise<void> {
    console.log('üîî Notification messages lus:', { conversationId, userId, lastMessageId });
    // WebSocket notification sera impl√©ment√©e
  }

  /**
   * ‚úÖ GARDE ADMIN - Cr√©er une notification de nouveau chat (syst√®me)
   */
  private async createChatNotification(recipientId: string, senderId: string, conversationId: string): Promise<void> {
    try {
      // R√©cup√©rer le nom de l'exp√©diteur avec supabaseAdmin
      const { data: senderProfile } = await supabaseAdmin
        .from('profiles')
        .select('name, avatar_url')
        .eq('id', senderId)
        .single();

      // Cr√©er la notification avec supabaseAdmin
      await supabaseAdmin
        .from('notifications')
        .insert({
          recipient_id: recipientId,
          sender_id: senderId,
          type: 'new_chat',
          title: 'Nouvelle conversation',
          message: `Vous pouvez maintenant discuter avec ${senderProfile?.name || 'cette personne'}`,
          status: 'unread',
          payload: {
            conversation_id: conversationId,
            sender_name: senderProfile?.name,
            sender_avatar: senderProfile?.avatar_url
          }
        });

    } catch (error) {
      console.error('‚ùå Erreur cr√©ation notification chat:', error);
    }
  }
}


export const chatService = new ChatService();// backend/src/modules/chat/chat.service.ts
// =============================================
// SERVICE BACKEND - Chat Syst√®me Temps R√©el avec NOUVEAU PATTERN RLS
// =============================================

import { supabaseAdmin } from '../../config/database';

// Types pour le chat
export interface Conversation {
  id: string;
  participant_1_id: string;
  participant_2_id: string;
  created_at: string;
  last_message_at: string;
  last_message_id: string | null;
  status: 'active' | 'archived' | 'blocked';
  other_participant?: {
    id: string;
    name: string;
    avatar_url: string | null;
  };
  unread_count?: number;
  last_message?: Message;
}

export interface Message {
  id: string;
  conversation_id: string;
  sender_id: string;
  content: string | null;
  message_type: 'text' | 'image' | 'voice' | 'system';
  media_url: string | null;
  media_metadata: any;
  reply_to_id: string | null;
  reactions: Record<string, string[]>;
  expires_at: string | null;
  edited_at: string | null;
  deleted_at: string | null;
  created_at: string;
  updated_at: string;
  sender?: {
    id: string;
    name: string;
    avatar_url: string | null;
  };
  reply_to?: Message;
}

export interface MessageRead {
  id: string;
  conversation_id: string;
  user_id: string;
  last_read_message_id: string | null;
  read_at: string;
}

// Interfaces pour les param√®tres
export interface CreateConversationParams {
  participant_1_id: string;
  participant_2_id: string;
}

export interface SendMessageParams {
  conversation_id: string;
  sender_id: string;
  content?: string;
  message_type?: 'text' | 'image' | 'voice' | 'system';
  media_url?: string;
  media_metadata?: any;
  reply_to_id?: string;
  expires_in_minutes?: number;
}

export interface UpdateMessageParams {
  message_id: string;
  user_id: string;
  content?: string;
  media_url?: string;
  media_metadata?: any;
}

export interface ReactToMessageParams {
  message_id: string;
  user_id: string;
  emoji: string;
  action: 'add' | 'remove';
}

class ChatService {
  private webSocketService?: any;

  setWebSocketService(webSocketService: any) {
    this.webSocketService = webSocketService;
  }

  // ============ GESTION DES CONVERSATIONS ============

  /**
   * ‚úÖ GARDE ADMIN - Cr√©er une nouvelle conversation (syst√®me apr√®s miroir accept√©)
   */
  async createConversation(params: CreateConversationParams): Promise<Conversation> {
    try {
      console.log('üí¨ Chat Service - Cr√©ation conversation:', params);

      // V√©rifier qu'une conversation n'existe pas d√©j√† entre ces utilisateurs
      const existingConversation = await this.findExistingConversation(
        params.participant_1_id,
        params.participant_2_id
      );

      if (existingConversation) {
        console.log('‚úÖ Conversation existante trouv√©e:', existingConversation.id);
        return existingConversation;
      }

      // Cr√©er la nouvelle conversation avec supabaseAdmin (syst√®me)
      const { data: newConversation, error } = await supabaseAdmin
        .from('conversations')
        .insert({
          participant_1_id: params.participant_1_id,
          participant_2_id: params.participant_2_id,
          created_at: new Date().toISOString(),
          last_message_at: new Date().toISOString()
        })
        .select()
        .single();

      if (error) {
        console.error('‚ùå Erreur cr√©ation conversation:', error);
        throw error;
      }

      console.log('‚úÖ Conversation cr√©√©e:', newConversation.id);

      // Envoyer un message syst√®me de bienvenue avec supabaseAdmin
      await this.sendSystemMessage({
        conversation_id: newConversation.id,
        sender_id: 'system',
        content: 'üéâ F√©licitations ! Vous pouvez maintenant discuter suite √† l\'acceptation du contact.',
        message_type: 'system'
      });

      // Cr√©er une notification pour les deux participants
      await this.notifyNewConversation(newConversation);

      return newConversation;

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur createConversation:', error);
      throw error;
    }
  }

  /**
   * ‚úÖ GARDE ADMIN - Chercher une conversation existante entre deux utilisateurs (syst√®me)
   */
  async findExistingConversation(userId1: string, userId2: string): Promise<Conversation | null> {
    try {
      const { data, error } = await supabaseAdmin
        .from('conversations')
        .select('*')
        .or(`and(participant_1_id.eq.${userId1},participant_2_id.eq.${userId2}),and(participant_1_id.eq.${userId2},participant_2_id.eq.${userId1})`)
        .single();

      if (error && error.code !== 'PGRST116') {
        throw error;
      }

      return data || null;
    } catch (error) {
      console.error('‚ùå Erreur findExistingConversation:', error);
      return null;
    }
  }

  /**
   * ‚úÖ CORRIG√â - R√©cup√©rer les conversations d'un utilisateur avec NOUVEAU PATTERN RLS
   */
  async getUserConversations(userId: string, userToken: string, limit: number = 20, offset: number = 0): Promise<Conversation[]> {
    try {
      console.log('üìù Chat Service - R√©cup√©ration conversations pour:', userId);

      // ‚úÖ Validation token
      const { data: { user }, error: tokenError } = await supabaseAdmin.auth.getUser(userToken);
      if (tokenError || !user || user.id !== userId) {
        throw new Error('Unauthorized');
      }

      // R√©cup√©rer les conversations avec supabaseAdmin + WHERE explicites
      const { data: conversations, error } = await supabaseAdmin
        .from('conversations')
        .select(`
          id,
          participant_1_id,
          participant_2_id,
          created_at,
          last_message_at,
          last_message_id,
          status
        `)
        .or(`participant_1_id.eq.${userId},participant_2_id.eq.${userId}`)
        .order('last_message_at', { ascending: false })
        .range(offset, offset + limit - 1);

      if (error) {
        console.error('‚ùå Erreur r√©cup√©ration conversations:', error);
        throw error;
      }

      if (!conversations || conversations.length === 0) {
        return [];
      }

      // Enrichir avec les donn√©es des autres participants
      const enrichedConversations = await Promise.all(
        conversations.map(async (conv) => {
          const otherUserId = conv.participant_1_id === userId
            ? conv.participant_2_id
            : conv.participant_1_id;

          // R√©cup√©rer les infos de l'autre participant avec supabaseAdmin (infos publiques)
          const { data: otherUser } = await supabaseAdmin
            .from('profiles')
            .select('id, name, avatar_url')
            .eq('id', otherUserId)
            .single();

          // R√©cup√©rer le dernier message
          let lastMessage = null;
          if (conv.last_message_id) {
            const { data: messageData } = await supabaseAdmin
              .from('messages')
              .select('id, content, message_type, created_at, sender_id')
              .eq('id', conv.last_message_id)
              .eq('conversation_id', conv.id)
              .single();
            lastMessage = messageData;
          }

          // Compter les messages non lus
          const unreadCount = await this.getUnreadMessagesCount(conv.id, userId, userToken);

          return {
            ...conv,
            other_participant: otherUser ? {
              id: otherUser.id,
              name: otherUser.name || 'Utilisateur',
              avatar_url: otherUser.avatar_url
            } : null,
            unread_count: unreadCount,
            last_message: lastMessage
          };
        })
      );

      console.log(`‚úÖ ${enrichedConversations.length} conversations r√©cup√©r√©es`);
      return enrichedConversations;

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur getUserConversations:', error);
      throw error;
    }
  }

  /**
   * ‚úÖ CORRIG√â - R√©cup√©rer une conversation sp√©cifique avec NOUVEAU PATTERN RLS
   */
  async getConversation(conversationId: string, userId: string, userToken: string): Promise<Conversation | null> {
    try {
      // ‚úÖ Validation token
      const { data: { user }, error: tokenError } = await supabaseAdmin.auth.getUser(userToken);
      if (tokenError || !user || user.id !== userId) {
        throw new Error('Unauthorized');
      }

      const { data: conversation, error } = await supabaseAdmin
        .from('conversations')
        .select('*')
        .eq('id', conversationId)
        .or(`participant_1_id.eq.${userId},participant_2_id.eq.${userId}`)
        .single();

      if (error || !conversation) {
        return null;
      }

      // Enrichir avec les donn√©es de l'autre participant
      const otherUserId = conversation.participant_1_id === userId
        ? conversation.participant_2_id
        : conversation.participant_1_id;

      const { data: otherUser } = await supabaseAdmin
        .from('profiles')
        .select('id, name, avatar_url')
        .eq('id', otherUserId)
        .single();

      return {
        ...conversation,
        other_participant: otherUser ? {
          id: otherUser.id,
          name: otherUser.name || 'Utilisateur',
          avatar_url: otherUser.avatar_url
        } : null
      };

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur getConversation:', error);
      throw error;
    }
  }

  // ============ GESTION DES MESSAGES ============

  /**
   * ‚úÖ CORRIG√â - Envoyer un message avec NOUVEAU PATTERN RLS
   */
  async sendMessage(params: SendMessageParams, userToken: string): Promise<Message> {
    try {
      console.log('üì§ Chat Service - Envoi message:', params);

      // ‚úÖ Validation token
      const { data: { user }, error: tokenError } = await supabaseAdmin.auth.getUser(userToken);
      if (tokenError || !user || user.id !== params.sender_id) {
        throw new Error('Unauthorized');
      }

      // V√©rifier que l'utilisateur a acc√®s √† cette conversation
      const conversation = await this.getConversation(params.conversation_id, params.sender_id, userToken);
      if (!conversation) {
        throw new Error('Conversation not found or access denied');
      }

      // Calculer la date d'expiration si message √©ph√©m√®re
      let expiresAt = null;
      if (params.expires_in_minutes) {
        expiresAt = new Date();
        expiresAt.setMinutes(expiresAt.getMinutes() + params.expires_in_minutes);
      }

      // Ins√©rer le message avec supabaseAdmin
      const { data: newMessage, error } = await supabaseAdmin
        .from('messages')
        .insert({
          conversation_id: params.conversation_id,
          sender_id: params.sender_id,
          content: params.content || null,
          message_type: params.message_type || 'text',
          media_url: params.media_url || null,
          media_metadata: params.media_metadata || null,
          reply_to_id: params.reply_to_id || null,
          expires_at: expiresAt?.toISOString() || null,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        })
        .select()
        .single();

      if (error) {
        console.error('‚ùå Erreur envoi message:', error);
        throw error;
      }

      // Mettre √† jour le last_message_at de la conversation
      await supabaseAdmin
        .from('conversations')
        .update({
          last_message_at: new Date().toISOString(),
          last_message_id: newMessage.id
        })
        .eq('id', params.conversation_id);

      console.log('‚úÖ Message envoy√©:', newMessage.id);

      // R√©cup√©rer le message enrichi
      const enrichedMessage = await this.getMessageWithDetails(newMessage.id, userToken);

      // Notifier les participants via WebSocket
      await this.notifyNewMessage(enrichedMessage);

      return enrichedMessage;

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur sendMessage:', error);
      throw error;
    }
  }

  /**
   * ‚úÖ GARDE ADMIN - Envoyer un message syst√®me (sans RLS)
   */
  private async sendSystemMessage(params: SendMessageParams): Promise<Message> {
    try {
      // Calculer la date d'expiration si message √©ph√©m√®re
      let expiresAt = null;
      if (params.expires_in_minutes) {
        expiresAt = new Date();
        expiresAt.setMinutes(expiresAt.getMinutes() + params.expires_in_minutes);
      }

      // Ins√©rer le message syst√®me avec supabaseAdmin
      const { data: newMessage, error } = await supabaseAdmin
        .from('messages')
        .insert({
          conversation_id: params.conversation_id,
          sender_id: params.sender_id,
          content: params.content || null,
          message_type: params.message_type || 'system',
          media_url: params.media_url || null,
          media_metadata: params.media_metadata || null,
          reply_to_id: params.reply_to_id || null,
          expires_at: expiresAt?.toISOString() || null,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        })
        .select()
        .single();

      if (error) {
        console.error('‚ùå Erreur envoi message syst√®me:', error);
        throw error;
      }

      // Mettre √† jour le last_message_at de la conversation
      await supabaseAdmin
        .from('conversations')
        .update({
          last_message_at: new Date().toISOString(),
          last_message_id: newMessage.id
        })
        .eq('id', params.conversation_id);

      console.log('‚úÖ Message syst√®me envoy√©:', newMessage.id);
      return newMessage;

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur sendSystemMessage:', error);
      throw error;
    }
  }

  /**
   * ‚úÖ CORRIG√â - R√©cup√©rer les messages d'une conversation avec NOUVEAU PATTERN RLS
   */
  async getConversationMessages(
    conversationId: string,
    userId: string,
    userToken: string,
    limit: number = 50,
    offset: number = 0
  ): Promise<Message[]> {
    try {
      console.log('üìã Chat Service - R√©cup√©ration messages conversation:', conversationId);

      // ‚úÖ Validation token
      const { data: { user }, error: tokenError } = await supabaseAdmin.auth.getUser(userToken);
      if (tokenError || !user || user.id !== userId) {
        throw new Error('Unauthorized');
      }

      // V√©rifier que l'utilisateur a acc√®s √† cette conversation
      const conversation = await this.getConversation(conversationId, userId, userToken);
      if (!conversation) {
        throw new Error('Conversation not found or access denied');
      }

      // R√©cup√©rer les messages avec supabaseAdmin
      const { data: messages, error } = await supabaseAdmin
        .from('messages')
        .select(`
          id,
          conversation_id,
          sender_id,
          content,
          message_type,
          media_url,
          media_metadata,
          reply_to_id,
          reactions,
          expires_at,
          edited_at,
          deleted_at,
          created_at,
          updated_at
        `)
        .eq('conversation_id', conversationId)
        .is('deleted_at', null)
        .order('created_at', { ascending: false })
        .range(offset, offset + limit - 1);

      if (error) {
        console.error('‚ùå Erreur r√©cup√©ration messages:', error);
        throw error;
      }

      if (!messages || messages.length === 0) {
        return [];
      }

      // Enrichir les messages avec les donn√©es des senders
      const enrichedMessages = await Promise.all(
        messages.map(async (message) => {
          // R√©cup√©rer les infos du sender (sauf pour les messages syst√®me)
          let sender = null;
          if (message.sender_id !== 'system') {
            const { data: senderData } = await supabaseAdmin
              .from('profiles')
              .select('id, name, avatar_url')
              .eq('id', message.sender_id)
              .single();

            sender = senderData ? {
              id: senderData.id,
              name: senderData.name || 'Utilisateur',
              avatar_url: senderData.avatar_url
            } : null;
          }

          // R√©cup√©rer le message de r√©ponse si applicable
          let replyTo = null;
          if (message.reply_to_id) {
            try {
              replyTo = await this.getMessageWithDetails(message.reply_to_id, userToken);
            } catch (e) {
              // Message de r√©ponse non accessible, continuer
            }
          }

          return {
            ...message,
            sender,
            reply_to: replyTo
          };
        })
      );

      console.log(`‚úÖ ${enrichedMessages.length} messages r√©cup√©r√©s`);
      return enrichedMessages.reverse(); // Plus ancien en premier

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur getConversationMessages:', error);
      throw error;
    }
  }

  /**
   * ‚úÖ CORRIG√â - Modifier un message avec NOUVEAU PATTERN RLS
   */
  async updateMessage(params: UpdateMessageParams, userToken: string): Promise<Message> {
    try {
      console.log('‚úèÔ∏è Chat Service - Modification message:', params.message_id);

      // ‚úÖ Validation token
      const { data: { user }, error: tokenError } = await supabaseAdmin.auth.getUser(userToken);
      if (tokenError || !user || user.id !== params.user_id) {
        throw new Error('Unauthorized');
      }

      // V√©rifier que l'utilisateur est le propri√©taire du message
      const { data: existingMessage } = await supabaseAdmin
        .from('messages')
        .select('sender_id, conversation_id')
        .eq('id', params.message_id)
        .eq('sender_id', params.user_id)
        .single();

      if (!existingMessage) {
        throw new Error('Message not found or access denied');
      }

      // Mettre √† jour le message avec supabaseAdmin
      const { data: updatedMessage, error } = await supabaseAdmin
        .from('messages')
        .update({
          content: params.content,
          media_url: params.media_url,
          media_metadata: params.media_metadata,
          edited_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        })
        .eq('id', params.message_id)
        .eq('sender_id', params.user_id)
        .select()
        .single();

      if (error) {
        console.error('‚ùå Erreur modification message:', error);
        throw error;
      }

      // R√©cup√©rer le message enrichi
      const enrichedMessage = await this.getMessageWithDetails(updatedMessage.id, userToken);

      // Notifier la modification via WebSocket
      await this.notifyMessageUpdated(enrichedMessage);

      return enrichedMessage;

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur updateMessage:', error);
      throw error;
    }
  }

  /**
   * ‚úÖ CORRIG√â - Supprimer un message avec NOUVEAU PATTERN RLS
   */
  async deleteMessage(messageId: string, userId: string, userToken: string): Promise<boolean> {
    try {
      console.log('üóëÔ∏è Chat Service - Suppression message:', messageId);

      // ‚úÖ Validation token
      const { data: { user }, error: tokenError } = await supabaseAdmin.auth.getUser(userToken);
      if (tokenError || !user || user.id !== userId) {
        throw new Error('Unauthorized');
      }

      // V√©rifier que l'utilisateur est le propri√©taire du message
      const { data: existingMessage } = await supabaseAdmin
        .from('messages')
        .select('sender_id')
        .eq('id', messageId)
        .eq('sender_id', userId)
        .single();

      if (!existingMessage) {
        throw new Error('Message not found or access denied');
      }

      // Soft delete avec supabaseAdmin
      const { error } = await supabaseAdmin
        .from('messages')
        .update({
          deleted_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        })
        .eq('id', messageId)
        .eq('sender_id', userId);

      if (error) {
        console.error('‚ùå Erreur suppression message:', error);
        throw error;
      }

      // Notifier la suppression via WebSocket
      await this.notifyMessageDeleted(messageId);

      return true;

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur deleteMessage:', error);
      throw error;
    }
  }

  /**
   * ‚úÖ CORRIG√â - R√©agir √† un message avec NOUVEAU PATTERN RLS
   */
  async reactToMessage(params: ReactToMessageParams, userToken: string): Promise<Message> {
    try {
      console.log('üòä Chat Service - R√©action message:', params);

      // ‚úÖ Validation token
      const { data: { user }, error: tokenError } = await supabaseAdmin.auth.getUser(userToken);
      if (tokenError || !user || user.id !== params.user_id) {
        throw new Error('Unauthorized');
      }

      // R√©cup√©rer le message existant
      const { data: message, error } = await supabaseAdmin
        .from('messages')
        .select('reactions, conversation_id')
        .eq('id', params.message_id)
        .single();

      if (error || !message) {
        throw new Error('Message not found');
      }

      // V√©rifier acc√®s √† la conversation
      const conversation = await this.getConversation(message.conversation_id, params.user_id, userToken);
      if (!conversation) {
        throw new Error('Access denied to conversation');
      }

      // Modifier les r√©actions
      const reactions = message.reactions || {};
      const emoji = params.emoji;
      const userId = params.user_id;

      if (params.action === 'add') {
        if (!reactions[emoji]) {
          reactions[emoji] = [];
        }
        if (!reactions[emoji].includes(userId)) {
          reactions[emoji].push(userId);
        }
      } else {
        if (reactions[emoji]) {
          reactions[emoji] = reactions[emoji].filter(id => id !== userId);
          if (reactions[emoji].length === 0) {
            delete reactions[emoji];
          }
        }
      }

      // Mettre √† jour en base avec supabaseAdmin
      const { data: updatedMessage, error: updateError } = await supabaseAdmin
        .from('messages')
        .update({
          reactions: reactions,
          updated_at: new Date().toISOString()
        })
        .eq('id', params.message_id)
        .select()
        .single();

      if (updateError) {
        throw updateError;
      }

      // R√©cup√©rer le message enrichi
      const enrichedMessage = await this.getMessageWithDetails(updatedMessage.id, userToken);

      // Notifier via WebSocket
      await this.notifyMessageReaction(enrichedMessage, params.emoji, params.action);

      return enrichedMessage;

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur reactToMessage:', error);
      throw error;
    }
  }

  // ============ GESTION DES LECTURES ============

  /**
   * ‚úÖ CORRIG√â - Marquer les messages comme lus avec NOUVEAU PATTERN RLS
   */
  async markMessagesAsRead(conversationId: string, userId: string, lastMessageId: string, userToken: string): Promise<void> {
    try {
      console.log('‚úÖ Chat Service - Marquage lu:', { conversationId, userId, lastMessageId });

      // ‚úÖ Validation token
      const { data: { user }, error: tokenError } = await supabaseAdmin.auth.getUser(userToken);
      if (tokenError || !user || user.id !== userId) {
        throw new Error('Unauthorized');
      }

      // V√©rifier acc√®s √† la conversation
      const conversation = await this.getConversation(conversationId, userId, userToken);
      if (!conversation) {
        throw new Error('Access denied to conversation');
      }

      // Upsert du marqueur de lecture avec supabaseAdmin
      const { error } = await supabaseAdmin
        .from('message_reads')
        .upsert({
          conversation_id: conversationId,
          user_id: userId,
          last_read_message_id: lastMessageId,
          read_at: new Date().toISOString()
        }, {
          onConflict: 'conversation_id,user_id'
        });

      if (error) {
        console.error('‚ùå Erreur marquage lu:', error);
        throw error;
      }

      // Notifier via WebSocket que les messages ont √©t√© lus
      await this.notifyMessagesRead(conversationId, userId, lastMessageId);

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur markMessagesAsRead:', error);
      throw error;
    }
  }

  /**
   * ‚úÖ CORRIG√â - Compter les messages non lus avec NOUVEAU PATTERN RLS
   */
  async getUnreadMessagesCount(conversationId: string, userId: string, userToken: string): Promise<number> {
    try {
      // ‚úÖ Validation token
      const { data: { user }, error: tokenError } = await supabaseAdmin.auth.getUser(userToken);
      if (tokenError || !user || user.id !== userId) {
        return 0;
      }

      // R√©cup√©rer le dernier message lu
      const { data: lastRead } = await supabaseAdmin
        .from('message_reads')
        .select('last_read_message_id')
        .eq('conversation_id', conversationId)
        .eq('user_id', userId)
        .single();

      if (!lastRead || !lastRead.last_read_message_id) {
        // Compter tous les messages non supprim√©s dans la conversation (pas de l'utilisateur)
        const { count } = await supabaseAdmin
          .from('messages')
          .select('*', { count: 'exact', head: true })
          .eq('conversation_id', conversationId)
          .neq('sender_id', userId)
          .is('deleted_at', null);

        return count || 0;
      }

      // Compter les messages apr√®s le dernier lu
      const { data: lastReadMessage } = await supabaseAdmin
        .from('messages')
        .select('created_at')
        .eq('id', lastRead.last_read_message_id)
        .single();

      if (!lastReadMessage) return 0;

      const { count } = await supabaseAdmin
        .from('messages')
        .select('*', { count: 'exact', head: true })
        .eq('conversation_id', conversationId)
        .neq('sender_id', userId)
        .gt('created_at', lastReadMessage.created_at)
        .is('deleted_at', null);

      return count || 0;

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur getUnreadMessagesCount:', error);
      return 0;
    }
  }

  /**
   * ‚úÖ CORRIG√â - R√©cup√©rer le nombre total de conversations non lues avec NOUVEAU PATTERN RLS
   */
  async getTotalUnreadConversationsCount(userId: string, userToken: string): Promise<number> {
    try {
      const conversations = await this.getUserConversations(userId, userToken, 100, 0);
      return conversations.filter(conv => (conv.unread_count || 0) > 0).length;
    } catch (error) {
      console.error('‚ùå Chat Service - Erreur getTotalUnreadConversationsCount:', error);
      return 0;
    }
  }

  // ============ INT√âGRATION AVEC LE SYST√àME DE MIROIR ============

  /**
   * ‚úÖ GARDE ADMIN - Cr√©er automatiquement une conversation apr√®s acceptation d'un contact
   */
  async createConversationFromMirrorAcceptance(senderId: string, receiverId: string): Promise<Conversation> {
    try {
      console.log('ü™û‚û°Ô∏èüí¨ Cr√©ation conversation depuis contact accept√©:', { senderId, receiverId });

      // Cr√©er la conversation (utilise supabaseAdmin car syst√®me)
      const conversation = await this.createConversation({
        participant_1_id: senderId,
        participant_2_id: receiverId
      });

      // Cr√©er une notification sp√©ciale pour les deux utilisateurs
      await this.createChatNotification(senderId, receiverId, conversation.id);
      await this.createChatNotification(receiverId, senderId, conversation.id);

      return conversation;

    } catch (error) {
      console.error('‚ùå Erreur createConversationFromMirrorAcceptance:', error);
      throw error;
    }
  }

  // ============ M√âTHODES PRIV√âES ============

  /**
   * ‚úÖ CORRIG√â - R√©cup√©rer un message avec tous ses d√©tails avec NOUVEAU PATTERN RLS
   */
  private async getMessageWithDetails(messageId: string, userToken: string): Promise<Message> {
    // ‚úÖ Validation token
    const { data: { user }, error: tokenError } = await supabaseAdmin.auth.getUser(userToken);
    if (tokenError || !user) {
      throw new Error('Unauthorized');
    }

    const { data: message, error } = await supabaseAdmin
      .from('messages')
      .select('*')
      .eq('id', messageId)
      .single();

    if (error || !message) {
      throw new Error('Message not found');
    }

    // Enrichir avec les donn√©es du sender (sauf pour les messages syst√®me)
    let sender = null;
    if (message.sender_id !== 'system') {
      const { data: senderData } = await supabaseAdmin
        .from('profiles')
        .select('id, name, avatar_url')
        .eq('id', message.sender_id)
        .single();

      sender = senderData ? {
        id: senderData.id,
        name: senderData.name || 'Utilisateur',
        avatar_url: senderData.avatar_url
      } : null;
    }

    return {
      ...message,
      sender
    };
  }

  /**
   * Notifier une nouvelle conversation
   */
  private async notifyNewConversation(conversation: Conversation): Promise<void> {
    console.log('üîî Notification nouvelle conversation:', conversation.id);

    if (this.webSocketService) {
      this.webSocketService.notifyNewConversation([
        conversation.participant_1_id,
        conversation.participant_2_id
      ], conversation);
    }
  }

  /**
   * Notifier un nouveau message
   */
  private async notifyNewMessage(message: Message): Promise<void> {
    console.log('üîî Notification nouveau message:', message.id);

    if (this.webSocketService) {
      this.webSocketService.notifyNewMessage(
        message.conversation_id,
        message,
        message.sender_id
      );
    }
  }

  /**
   * Notifier la modification d'un message
   */
  private async notifyMessageUpdated(message: Message): Promise<void> {
    console.log('üîî Notification message modifi√©:', message.id);

    if (this.webSocketService) {
      this.webSocketService.notifyMessageUpdate(message.conversation_id, message);
    }
  }

  /**
   * Notifier la suppression d'un message
   */
  private async notifyMessageDeleted(messageId: string): Promise<void> {
    console.log('üîî Notification message supprim√©:', messageId);

    // R√©cup√©rer l'info de la conversation depuis le message
    const { data: message } = await supabaseAdmin
      .from('messages')
      .select('conversation_id')
      .eq('id', messageId)
      .single();

    if (this.webSocketService && message) {
      this.webSocketService.notifyMessageDeleted(message.conversation_id, messageId);
    }
  }

  /**
   * Notifier une r√©action
   */
  private async notifyMessageReaction(message: Message, emoji: string, action: 'add' | 'remove'): Promise<void> {
    console.log('üîî Notification r√©action:', { messageId: message.id, emoji, action });

    if (this.webSocketService) {
      this.webSocketService.notifyMessageReaction(
        message.conversation_id,
        message.id,
        emoji,
        action,
        message.sender_id
      );
    }
  }

  /**
   * Notifier que des messages ont √©t√© lus
   */
  private async notifyMessagesRead(conversationId: string, userId: string, lastMessageId: string): Promise<void> {
    console.log('üîî Notification messages lus:', { conversationId, userId, lastMessageId });
    // WebSocket notification sera impl√©ment√©e
  }

  /**
   * ‚úÖ GARDE ADMIN - Cr√©er une notification de nouveau chat (syst√®me)
   */
  private async createChatNotification(recipientId: string, senderId: string, conversationId: string): Promise<void> {
    try {
      // R√©cup√©rer le nom de l'exp√©diteur avec supabaseAdmin
      const { data: senderProfile } = await supabaseAdmin
        .from('profiles')
        .select('name, avatar_url')
        .eq('id', senderId)
        .single();

      // Cr√©er la notification avec supabaseAdmin
      await supabaseAdmin
        .from('notifications')
        .insert({
          recipient_id: recipientId,
          sender_id: senderId,
          type: 'new_chat',
          title: 'Nouvelle conversation',
          message: `Vous pouvez maintenant discuter avec ${senderProfile?.name || 'cette personne'}`,
          status: 'unread',
          payload: {
            conversation_id: conversationId,
            sender_name: senderProfile?.name,
            sender_avatar: senderProfile?.avatar_url
          }
        });

    } catch (error) {
      console.error('‚ùå Erreur cr√©ation notification chat:', error);
    }
  }
}

export const chatService = new ChatService();// backend/src/modules/chat/chat.service.ts
// =============================================
// SERVICE BACKEND - Chat Syst√®me Temps R√©el avec NOUVEAU PATTERN RLS
// =============================================

import { supabaseAdmin } from '../../config/database';

// Types pour le chat
export interface Conversation {
  id: string;
  participant_1_id: string;
  participant_2_id: string;
  created_at: string;
  last_message_at: string;
  last_message_id: string | null;
  status: 'active' | 'archived' | 'blocked';
  other_participant?: {
    id: string;
    name: string;
    avatar_url: string | null;
  };
  unread_count?: number;
  last_message?: Message;
}

export interface Message {
  id: string;
  conversation_id: string;
  sender_id: string;
  content: string | null;
  message_type: 'text' | 'image' | 'voice' | 'system';
  media_url: string | null;
  media_metadata: any;
  reply_to_id: string | null;
  reactions: Record<string, string[]>;
  expires_at: string | null;
  edited_at: string | null;
  deleted_at: string | null;
  created_at: string;
  updated_at: string;
  sender?: {
    id: string;
    name: string;
    avatar_url: string | null;
  };
  reply_to?: Message;
}

export interface MessageRead {
  id: string;
  conversation_id: string;
  user_id: string;
  last_read_message_id: string | null;
  read_at: string;
}

// Interfaces pour les param√®tres
export interface CreateConversationParams {
  participant_1_id: string;
  participant_2_id: string;
}

export interface SendMessageParams {
  conversation_id: string;
  sender_id: string;
  content?: string;
  message_type?: 'text' | 'image' | 'voice' | 'system';
  media_url?: string;
  media_metadata?: any;
  reply_to_id?: string;
  expires_in_minutes?: number;
}

export interface UpdateMessageParams {
  message_id: string;
  user_id: string;
  content?: string;
  media_url?: string;
  media_metadata?: any;
}

export interface ReactToMessageParams {
  message_id: string;
  user_id: string;
  emoji: string;
  action: 'add' | 'remove';
}

class ChatService {
  private webSocketService?: any;

  setWebSocketService(webSocketService: any) {
    this.webSocketService = webSocketService;
  }

  // ============ GESTION DES CONVERSATIONS ============

  /**
   * ‚úÖ GARDE ADMIN - Cr√©er une nouvelle conversation (syst√®me apr√®s miroir accept√©)
   */
  async createConversation(params: CreateConversationParams): Promise<Conversation> {
    try {
      console.log('üí¨ Chat Service - Cr√©ation conversation:', params);

      // V√©rifier qu'une conversation n'existe pas d√©j√† entre ces utilisateurs
      const existingConversation = await this.findExistingConversation(
        params.participant_1_id,
        params.participant_2_id
      );

      if (existingConversation) {
        console.log('‚úÖ Conversation existante trouv√©e:', existingConversation.id);
        return existingConversation;
      }

      // Cr√©er la nouvelle conversation avec supabaseAdmin (syst√®me)
      const { data: newConversation, error } = await supabaseAdmin
        .from('conversations')
        .insert({
          participant_1_id: params.participant_1_id,
          participant_2_id: params.participant_2_id,
          created_at: new Date().toISOString(),
          last_message_at: new Date().toISOString()
        })
        .select()
        .single();

      if (error) {
        console.error('‚ùå Erreur cr√©ation conversation:', error);
        throw error;
      }

      console.log('‚úÖ Conversation cr√©√©e:', newConversation.id);

      // Envoyer un message syst√®me de bienvenue avec supabaseAdmin
      await this.sendSystemMessage({
        conversation_id: newConversation.id,
        sender_id: 'system',
        content: 'üéâ F√©licitations ! Vous pouvez maintenant discuter suite √† l\'acceptation du contact.',
        message_type: 'system'
      });

      // Cr√©er une notification pour les deux participants
      await this.notifyNewConversation(newConversation);

      return newConversation;

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur createConversation:', error);
      throw error;
    }
  }

  /**
   * ‚úÖ GARDE ADMIN - Chercher une conversation existante entre deux utilisateurs (syst√®me)
   */
  async findExistingConversation(userId1: string, userId2: string): Promise<Conversation | null> {
    try {
      const { data, error } = await supabaseAdmin
        .from('conversations')
        .select('*')
        .or(`and(participant_1_id.eq.${userId1},participant_2_id.eq.${userId2}),and(participant_1_id.eq.${userId2},participant_2_id.eq.${userId1})`)
        .single();

      if (error && error.code !== 'PGRST116') {
        throw error;
      }

      return data || null;
    } catch (error) {
      console.error('‚ùå Erreur findExistingConversation:', error);
      return null;
    }
  }

  /**
   * ‚úÖ CORRIG√â - R√©cup√©rer les conversations d'un utilisateur avec NOUVEAU PATTERN RLS
   */
  async getUserConversations(userId: string, userToken: string, limit: number = 20, offset: number = 0): Promise<Conversation[]> {
    try {
      console.log('üìù Chat Service - R√©cup√©ration conversations pour:', userId);

      // ‚úÖ Validation token
      const { data: { user }, error: tokenError } = await supabaseAdmin.auth.getUser(userToken);
      if (tokenError || !user || user.id !== userId) {
        throw new Error('Unauthorized');
      }

      // R√©cup√©rer les conversations avec supabaseAdmin + WHERE explicites
      const { data: conversations, error } = await supabaseAdmin
        .from('conversations')
        .select(`
          id,
          participant_1_id,
          participant_2_id,
          created_at,
          last_message_at,
          last_message_id,
          status
        `)
        .or(`participant_1_id.eq.${userId},participant_2_id.eq.${userId}`)
        .order('last_message_at', { ascending: false })
        .range(offset, offset + limit - 1);

      if (error) {
        console.error('‚ùå Erreur r√©cup√©ration conversations:', error);
        throw error;
      }

      if (!conversations || conversations.length === 0) {
        return [];
      }

      // Enrichir avec les donn√©es des autres participants
      const enrichedConversations = await Promise.all(
        conversations.map(async (conv) => {
          const otherUserId = conv.participant_1_id === userId
            ? conv.participant_2_id
            : conv.participant_1_id;

          // R√©cup√©rer les infos de l'autre participant avec supabaseAdmin (infos publiques)
          const { data: otherUser } = await supabaseAdmin
            .from('profiles')
            .select('id, name, avatar_url')
            .eq('id', otherUserId)
            .single();

          // R√©cup√©rer le dernier message
          let lastMessage = null;
          if (conv.last_message_id) {
            const { data: messageData } = await supabaseAdmin
              .from('messages')
              .select('id, content, message_type, created_at, sender_id')
              .eq('id', conv.last_message_id)
              .eq('conversation_id', conv.id)
              .single();
            lastMessage = messageData;
          }

          // Compter les messages non lus
          const unreadCount = await this.getUnreadMessagesCount(conv.id, userId, userToken);

          return {
            ...conv,
            other_participant: otherUser ? {
              id: otherUser.id,
              name: otherUser.name || 'Utilisateur',
              avatar_url: otherUser.avatar_url
            } : null,
            unread_count: unreadCount,
            last_message: lastMessage
          };
        })
      );

      console.log(`‚úÖ ${enrichedConversations.length} conversations r√©cup√©r√©es`);
      return enrichedConversations;

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur getUserConversations:', error);
      throw error;
    }
  }

  /**
   * ‚úÖ CORRIG√â - R√©cup√©rer une conversation sp√©cifique avec NOUVEAU PATTERN RLS
   */
  async getConversation(conversationId: string, userId: string, userToken: string): Promise<Conversation | null> {
    try {
      // ‚úÖ Validation token
      const { data: { user }, error: tokenError } = await supabaseAdmin.auth.getUser(userToken);
      if (tokenError || !user || user.id !== userId) {
        throw new Error('Unauthorized');
      }

      const { data: conversation, error } = await supabaseAdmin
        .from('conversations')
        .select('*')
        .eq('id', conversationId)
        .or(`participant_1_id.eq.${userId},participant_2_id.eq.${userId}`)
        .single();

      if (error || !conversation) {
        return null;
      }

      // Enrichir avec les donn√©es de l'autre participant
      const otherUserId = conversation.participant_1_id === userId
        ? conversation.participant_2_id
        : conversation.participant_1_id;

      const { data: otherUser } = await supabaseAdmin
        .from('profiles')
        .select('id, name, avatar_url')
        .eq('id', otherUserId)
        .single();

      return {
        ...conversation,
        other_participant: otherUser ? {
          id: otherUser.id,
          name: otherUser.name || 'Utilisateur',
          avatar_url: otherUser.avatar_url
        } : null
      };

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur getConversation:', error);
      throw error;
    }
  }

  // ============ GESTION DES MESSAGES ============

  /**
   * ‚úÖ CORRIG√â - Envoyer un message avec NOUVEAU PATTERN RLS
   */
  async sendMessage(params: SendMessageParams, userToken: string): Promise<Message> {
    try {
      console.log('üì§ Chat Service - Envoi message:', params);

      // ‚úÖ Validation token
      const { data: { user }, error: tokenError } = await supabaseAdmin.auth.getUser(userToken);
      if (tokenError || !user || user.id !== params.sender_id) {
        throw new Error('Unauthorized');
      }

      // V√©rifier que l'utilisateur a acc√®s √† cette conversation
      const conversation = await this.getConversation(params.conversation_id, params.sender_id, userToken);
      if (!conversation) {
        throw new Error('Conversation not found or access denied');
      }

      // Calculer la date d'expiration si message √©ph√©m√®re
      let expiresAt = null;
      if (params.expires_in_minutes) {
        expiresAt = new Date();
        expiresAt.setMinutes(expiresAt.getMinutes() + params.expires_in_minutes);
      }

      // Ins√©rer le message avec supabaseAdmin
      const { data: newMessage, error } = await supabaseAdmin
        .from('messages')
        .insert({
          conversation_id: params.conversation_id,
          sender_id: params.sender_id,
          content: params.content || null,
          message_type: params.message_type || 'text',
          media_url: params.media_url || null,
          media_metadata: params.media_metadata || null,
          reply_to_id: params.reply_to_id || null,
          expires_at: expiresAt?.toISOString() || null,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        })
        .select()
        .single();

      if (error) {
        console.error('‚ùå Erreur envoi message:', error);
        throw error;
      }

      // Mettre √† jour le last_message_at de la conversation
      await supabaseAdmin
        .from('conversations')
        .update({
          last_message_at: new Date().toISOString(),
          last_message_id: newMessage.id
        })
        .eq('id', params.conversation_id);

      console.log('‚úÖ Message envoy√©:', newMessage.id);

      // R√©cup√©rer le message enrichi
      const enrichedMessage = await this.getMessageWithDetails(newMessage.id, userToken);

      // Notifier les participants via WebSocket
      await this.notifyNewMessage(enrichedMessage);

      return enrichedMessage;

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur sendMessage:', error);
      throw error;
    }
  }

  /**
   * ‚úÖ GARDE ADMIN - Envoyer un message syst√®me (sans RLS)
   */
  private async sendSystemMessage(params: SendMessageParams): Promise<Message> {
    try {
      // Calculer la date d'expiration si message √©ph√©m√®re
      let expiresAt = null;
      if (params.expires_in_minutes) {
        expiresAt = new Date();
        expiresAt.setMinutes(expiresAt.getMinutes() + params.expires_in_minutes);
      }

      // Ins√©rer le message syst√®me avec supabaseAdmin
      const { data: newMessage, error } = await supabaseAdmin
        .from('messages')
        .insert({
          conversation_id: params.conversation_id,
          sender_id: params.sender_id,
          content: params.content || null,
          message_type: params.message_type || 'system',
          media_url: params.media_url || null,
          media_metadata: params.media_metadata || null,
          reply_to_id: params.reply_to_id || null,
          expires_at: expiresAt?.toISOString() || null,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        })
        .select()
        .single();

      if (error) {
        console.error('‚ùå Erreur envoi message syst√®me:', error);
        throw error;
      }

      // Mettre √† jour le last_message_at de la conversation
      await supabaseAdmin
        .from('conversations')
        .update({
          last_message_at: new Date().toISOString(),
          last_message_id: newMessage.id
        })
        .eq('id', params.conversation_id);

      console.log('‚úÖ Message syst√®me envoy√©:', newMessage.id);
      return newMessage;

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur sendSystemMessage:', error);
      throw error;
    }
  }

  /**
   * ‚úÖ CORRIG√â - R√©cup√©rer les messages d'une conversation avec NOUVEAU PATTERN RLS
   */
  async getConversationMessages(
    conversationId: string,
    userId: string,
    userToken: string,
    limit: number = 50,
    offset: number = 0
  ): Promise<Message[]> {
    try {
      console.log('üìã Chat Service - R√©cup√©ration messages conversation:', conversationId);

      // ‚úÖ Validation token
      const { data: { user }, error: tokenError } = await supabaseAdmin.auth.getUser(userToken);
      if (tokenError || !user || user.id !== userId) {
        throw new Error('Unauthorized');
      }

      // V√©rifier que l'utilisateur a acc√®s √† cette conversation
      const conversation = await this.getConversation(conversationId, userId, userToken);
      if (!conversation) {
        throw new Error('Conversation not found or access denied');
      }

      // R√©cup√©rer les messages avec supabaseAdmin
      const { data: messages, error } = await supabaseAdmin
        .from('messages')
        .select(`
          id,
          conversation_id,
          sender_id,
          content,
          message_type,
          media_url,
          media_metadata,
          reply_to_id,
          reactions,
          expires_at,
          edited_at,
          deleted_at,
          created_at,
          updated_at
        `)
        .eq('conversation_id', conversationId)
        .is('deleted_at', null)
        .order('created_at', { ascending: false })
        .range(offset, offset + limit - 1);

      if (error) {
        console.error('‚ùå Erreur r√©cup√©ration messages:', error);
        throw error;
      }

      if (!messages || messages.length === 0) {
        return [];
      }

      // Enrichir les messages avec les donn√©es des senders
      const enrichedMessages = await Promise.all(
        messages.map(async (message) => {
          // R√©cup√©rer les infos du sender (sauf pour les messages syst√®me)
          let sender = null;
          if (message.sender_id !== 'system') {
            const { data: senderData } = await supabaseAdmin
              .from('profiles')
              .select('id, name, avatar_url')
              .eq('id', message.sender_id)
              .single();

            sender = senderData ? {
              id: senderData.id,
              name: senderData.name || 'Utilisateur',
              avatar_url: senderData.avatar_url
            } : null;
          }

          // R√©cup√©rer le message de r√©ponse si applicable
          let replyTo = null;
          if (message.reply_to_id) {
            try {
              replyTo = await this.getMessageWithDetails(message.reply_to_id, userToken);
            } catch (e) {
              // Message de r√©ponse non accessible, continuer
            }
          }

          return {
            ...message,
            sender,
            reply_to: replyTo
          };
        })
      );

      console.log(`‚úÖ ${enrichedMessages.length} messages r√©cup√©r√©s`);
      return enrichedMessages.reverse(); // Plus ancien en premier

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur getConversationMessages:', error);
      throw error;
    }
  }

  /**
   * ‚úÖ CORRIG√â - Modifier un message avec NOUVEAU PATTERN RLS
   */
  async updateMessage(params: UpdateMessageParams, userToken: string): Promise<Message> {
    try {
      console.log('‚úèÔ∏è Chat Service - Modification message:', params.message_id);

      // ‚úÖ Validation token
      const { data: { user }, error: tokenError } = await supabaseAdmin.auth.getUser(userToken);
      if (tokenError || !user || user.id !== params.user_id) {
        throw new Error('Unauthorized');
      }

      // V√©rifier que l'utilisateur est le propri√©taire du message
      const { data: existingMessage } = await supabaseAdmin
        .from('messages')
        .select('sender_id, conversation_id')
        .eq('id', params.message_id)
        .eq('sender_id', params.user_id)
        .single();

      if (!existingMessage) {
        throw new Error('Message not found or access denied');
      }

      // Mettre √† jour le message avec supabaseAdmin
      const { data: updatedMessage, error } = await supabaseAdmin
        .from('messages')
        .update({
          content: params.content,
          media_url: params.media_url,
          media_metadata: params.media_metadata,
          edited_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        })
        .eq('id', params.message_id)
        .eq('sender_id', params.user_id)
        .select()
        .single();

      if (error) {
        console.error('‚ùå Erreur modification message:', error);
        throw error;
      }

      // R√©cup√©rer le message enrichi
      const enrichedMessage = await this.getMessageWithDetails(updatedMessage.id, userToken);

      // Notifier la modification via WebSocket
      await this.notifyMessageUpdated(enrichedMessage);

      return enrichedMessage;

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur updateMessage:', error);
      throw error;
    }
  }

  /**
   * ‚úÖ CORRIG√â - Supprimer un message avec NOUVEAU PATTERN RLS
   */
  async deleteMessage(messageId: string, userId: string, userToken: string): Promise<boolean> {
    try {
      console.log('üóëÔ∏è Chat Service - Suppression message:', messageId);

      // ‚úÖ Validation token
      const { data: { user }, error: tokenError } = await supabaseAdmin.auth.getUser(userToken);
      if (tokenError || !user || user.id !== userId) {
        throw new Error('Unauthorized');
      }

      // V√©rifier que l'utilisateur est le propri√©taire du message
      const { data: existingMessage } = await supabaseAdmin
        .from('messages')
        .select('sender_id')
        .eq('id', messageId)
        .eq('sender_id', userId)
        .single();

      if (!existingMessage) {
        throw new Error('Message not found or access denied');
      }

      // Soft delete avec supabaseAdmin
      const { error } = await supabaseAdmin
        .from('messages')
        .update({
          deleted_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        })
        .eq('id', messageId)
        .eq('sender_id', userId);

      if (error) {
        console.error('‚ùå Erreur suppression message:', error);
        throw error;
      }

      // Notifier la suppression via WebSocket
      await this.notifyMessageDeleted(messageId);

      return true;

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur deleteMessage:', error);
      throw error;
    }
  }

  /**
   * ‚úÖ CORRIG√â - R√©agir √† un message avec NOUVEAU PATTERN RLS
   */
  async reactToMessage(params: ReactToMessageParams, userToken: string): Promise<Message> {
    try {
      console.log('üòä Chat Service - R√©action message:', params);

      // ‚úÖ Validation token
      const { data: { user }, error: tokenError } = await supabaseAdmin.auth.getUser(userToken);
      if (tokenError || !user || user.id !== params.user_id) {
        throw new Error('Unauthorized');
      }

      // R√©cup√©rer le message existant
      const { data: message, error } = await supabaseAdmin
        .from('messages')
        .select('reactions, conversation_id')
        .eq('id', params.message_id)
        .single();

      if (error || !message) {
        throw new Error('Message not found');
      }

      // V√©rifier acc√®s √† la conversation
      const conversation = await this.getConversation(message.conversation_id, params.user_id, userToken);
      if (!conversation) {
        throw new Error('Access denied to conversation');
      }

      // Modifier les r√©actions
      const reactions = message.reactions || {};
      const emoji = params.emoji;
      const userId = params.user_id;

      if (params.action === 'add') {
        if (!reactions[emoji]) {
          reactions[emoji] = [];
        }
        if (!reactions[emoji].includes(userId)) {
          reactions[emoji].push(userId);
        }
      } else {
        if (reactions[emoji]) {
          reactions[emoji] = reactions[emoji].filter(id => id !== userId);
          if (reactions[emoji].length === 0) {
            delete reactions[emoji];
          }
        }
      }

      // Mettre √† jour en base avec supabaseAdmin
      const { data: updatedMessage, error: updateError } = await supabaseAdmin
        .from('messages')
        .update({
          reactions: reactions,
          updated_at: new Date().toISOString()
        })
        .eq('id', params.message_id)
        .select()
        .single();

      if (updateError) {
        throw updateError;
      }

      // R√©cup√©rer le message enrichi
      const enrichedMessage = await this.getMessageWithDetails(updatedMessage.id, userToken);

      // Notifier via WebSocket
      await this.notifyMessageReaction(enrichedMessage, params.emoji, params.action);

      return enrichedMessage;

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur reactToMessage:', error);
      throw error;
    }
  }

  // ============ GESTION DES LECTURES ============

  /**
   * ‚úÖ CORRIG√â - Marquer les messages comme lus avec NOUVEAU PATTERN RLS
   */
  async markMessagesAsRead(conversationId: string, userId: string, lastMessageId: string, userToken: string): Promise<void> {
    try {
      console.log('‚úÖ Chat Service - Marquage lu:', { conversationId, userId, lastMessageId });

      // ‚úÖ Validation token
      const { data: { user }, error: tokenError } = await supabaseAdmin.auth.getUser(userToken);
      if (tokenError || !user || user.id !== userId) {
        throw new Error('Unauthorized');
      }

      // V√©rifier acc√®s √† la conversation
      const conversation = await this.getConversation(conversationId, userId, userToken);
      if (!conversation) {
        throw new Error('Access denied to conversation');
      }

      // Upsert du marqueur de lecture avec supabaseAdmin
      const { error } = await supabaseAdmin
        .from('message_reads')
        .upsert({
          conversation_id: conversationId,
          user_id: userId,
          last_read_message_id: lastMessageId,
          read_at: new Date().toISOString()
        }, {
          onConflict: 'conversation_id,user_id'
        });

      if (error) {
        console.error('‚ùå Erreur marquage lu:', error);
        throw error;
      }

      // Notifier via WebSocket que les messages ont √©t√© lus
      await this.notifyMessagesRead(conversationId, userId, lastMessageId);

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur markMessagesAsRead:', error);
      throw error;
    }
  }

  /**
   * ‚úÖ CORRIG√â - Compter les messages non lus avec NOUVEAU PATTERN RLS
   */
  async getUnreadMessagesCount(conversationId: string, userId: string, userToken: string): Promise<number> {
    try {
      // ‚úÖ Validation token
      const { data: { user }, error: tokenError } = await supabaseAdmin.auth.getUser(userToken);
      if (tokenError || !user || user.id !== userId) {
        return 0;
      }

      // R√©cup√©rer le dernier message lu
      const { data: lastRead } = await supabaseAdmin
        .from('message_reads')
        .select('last_read_message_id')
        .eq('conversation_id', conversationId)
        .eq('user_id', userId)
        .single();

      if (!lastRead || !lastRead.last_read_message_id) {
        // Compter tous les messages non supprim√©s dans la conversation (pas de l'utilisateur)
        const { count } = await supabaseAdmin
          .from('messages')
          .select('*', { count: 'exact', head: true })
          .eq('conversation_id', conversationId)
          .neq('sender_id', userId)
          .is('deleted_at', null);

        return count || 0;
      }

      // Compter les messages apr√®s le dernier lu
      const { data: lastReadMessage } = await supabaseAdmin
        .from('messages')
        .select('created_at')
        .eq('id', lastRead.last_read_message_id)
        .single();

      if (!lastReadMessage) return 0;

      const { count } = await supabaseAdmin
        .from('messages')
        .select('*', { count: 'exact', head: true })
        .eq('conversation_id', conversationId)
        .neq('sender_id', userId)
        .gt('created_at', lastReadMessage.created_at)
        .is('deleted_at', null);

      return count || 0;

    } catch (error) {
      console.error('‚ùå Chat Service - Erreur getUnreadMessagesCount:', error);
      return 0;
    }
  }

  /**
   * ‚úÖ CORRIG√â - R√©cup√©rer le nombre total de conversations non lues avec NOUVEAU PATTERN RLS
   */
  async getTotalUnreadConversationsCount(userId: string, userToken: string): Promise<number> {
    try {
      const conversations = await this.getUserConversations(userId, userToken, 100, 0);
      return conversations.filter(conv => (conv.unread_count || 0) > 0).length;
    } catch (error) {
      console.error('‚ùå Chat Service - Erreur getTotalUnreadConversationsCount:', error);
      return 0;
    }
  }

  // ============ INT√âGRATION AVEC LE SYST√àME DE MIROIR ============

  /**
   * ‚úÖ GARDE ADMIN - Cr√©er automatiquement une conversation apr√®s acceptation d'un contact
   */
  async createConversationFromMirrorAcceptance(senderId: string, receiverId: string): Promise<Conversation> {
    try {
      console.log('ü™û‚û°Ô∏èüí¨ Cr√©ation conversation depuis contact accept√©:', { senderId, receiverId });

      // Cr√©er la conversation (utilise supabaseAdmin car syst√®me)
      const conversation = await this.createConversation({
        participant_1_id: senderId,
        participant_2_id: receiverId
      });

      // Cr√©er une notification sp√©ciale pour les deux utilisateurs
      await this.createChatNotification(senderId, receiverId, conversation.id);
      await this.createChatNotification(receiverId, senderId, conversation.id);

      return conversation;

    } catch (error) {
      console.error('‚ùå Erreur createConversationFromMirrorAcceptance:', error);
      throw error;
    }
  }

  // ============ M√âTHODES PRIV√âES ============

  /**
   * ‚úÖ CORRIG√â - R√©cup√©rer un message avec tous ses d√©tails avec NOUVEAU PATTERN RLS
   */
  private async getMessageWithDetails(messageId: string, userToken: string): Promise<Message> {
    // ‚úÖ Validation token
    const { data: { user }, error: tokenError } = await supabaseAdmin.auth.getUser(userToken);
    if (tokenError || !user) {
      throw new Error('Unauthorized');
    }

    const { data: message, error } = await supabaseAdmin
      .from('messages')
      .select('*')
      .eq('id', messageId)
      .single();

    if (error || !message) {
      throw new Error('Message not found');
    }

    // Enrichir avec les donn√©es du sender (sauf pour les messages syst√®me)
    let sender = null;
    if (message.sender_id !== 'system') {
      const { data: senderData } = await supabaseAdmin
        .from('profiles')
        .select('id, name, avatar_url')
        .eq('id', message.sender_id)
        .single();

      sender = senderData ? {
        id: senderData.id,
        name: senderData.name || 'Utilisateur',
        avatar_url: senderData.avatar_url
      } : null;
    }

    return {
      ...message,
      sender
    };
  }

  /**
   * Notifier une nouvelle conversation
   */
  private async notifyNewConversation(conversation: Conversation): Promise<void> {
    console.log('üîî Notification nouvelle conversation:', conversation.id);

    if (this.webSocketService) {
      this.webSocketService.notifyNewConversation([
        conversation.participant_1_id,
        conversation.participant_2_id
      ], conversation);
    }
  }

  /**
   * Notifier un nouveau message
   */
  private async notifyNewMessage(message: Message): Promise<void> {
    console.log('üîî Notification nouveau message:', message.id);

    if (this.webSocketService) {
      this.webSocketService.notifyNewMessage(
        message.conversation_id,
        message,
        message.sender_id
      );
    }
  }

  /**
   * Notifier la modification d'un message
   */
  private async notifyMessageUpdated(message: Message): Promise<void> {
    console.log('üîî Notification message modifi√©:', message.id);

    if (this.webSocketService) {
      this.webSocketService.notifyMessageUpdate(message.conversation_id, message);
    }
  }

  /**
   * Notifier la suppression d'un message
   */
  private async notifyMessageDeleted(messageId: string): Promise<void> {
    console.log('üîî Notification message supprim√©:', messageId);

    // R√©cup√©rer l'info de la conversation depuis le message
    const { data: message } = await supabaseAdmin
      .from('messages')
      .select('conversation_id')
      .eq('id', messageId)
      .single();

    if (this.webSocketService && message) {
      this.webSocketService.notifyMessageDeleted(message.conversation_id, messageId);
    }
  }

  /**
   * Notifier une r√©action
   */
  private async notifyMessageReaction(message: Message, emoji: string, action: 'add' | 'remove'): Promise<void> {
    console.log('üîî Notification r√©action:', { messageId: message.id, emoji, action });

    if (this.webSocketService) {
      this.webSocketService.notifyMessageReaction(
        message.conversation_id,
        message.id,
        emoji,
        action,
        message.sender_id
      );
    }
  }

  /**
   * Notifier que des messages ont √©t√© lus
   */
  private async notifyMessagesRead(conversationId: string, userId: string, lastMessageId: string): Promise<void> {
    console.log('üîî Notification messages lus:', { conversationId, userId, lastMessageId });
    // WebSocket notification sera impl√©ment√©e
  }

  /**
   * ‚úÖ GARDE ADMIN - Cr√©er une notification de nouveau chat (syst√®me)
   */
  private async createChatNotification(recipientId: string, senderId: string, conversationId: string): Promise<void> {
    try {
      // R√©cup√©rer le nom de l'exp√©diteur avec supabaseAdmin
      const { data: senderProfile } = await supabaseAdmin
        .from('profiles')
        .select('name, avatar_url')
        .eq('id', senderId)
        .single();

      // Cr√©er la notification avec supabaseAdmin
      await supabaseAdmin
        .from('notifications')
        .insert({
          recipient_id: recipientId,
          sender_id: senderId,
          type: 'new_chat',
          title: 'Nouvelle conversation',
          message: `Vous pouvez maintenant discuter avec ${senderProfile?.name || 'cette personne'}`,
          status: 'unread',
          payload: {
            conversation_id: conversationId,
            sender_name: senderProfile?.name,
            sender_avatar: senderProfile?.avatar_url
          }
        });

    } catch (error) {
      console.error('‚ùå Erreur cr√©ation notification chat:', error);
    }
  }
}


  // M√©thode pour connecter le service WebSocket
  setWebSocketService(webSocketService: any) {
    this.webSocketService = webSocketService;
  }
export const chatService = new ChatService();// =============================================


--- - ---

// SERVEUR WEBSOCKET COMPLET - backend/src/modules/chat/chat.websocket.ts
// =============================================

import { Server } from 'socket.io';
import { createServer } from 'http';
import { supabaseAdmin } from '../../config/database';
import type { Message, Conversation } from '../../../../shared/types/chat';

interface AuthenticatedSocket extends SocketIO.Socket {
  userId?: string;
  userName?: string;
}

interface OnlineUser {
  userId: string;
  userName: string;
  socketId: string;
  lastSeen: Date;
  isTyping: boolean;
  currentConversation?: string;
}

class ChatWebSocketServer {
  private io: Server | null = null;
  private onlineUsers = new Map<string, OnlineUser>();
  private userSockets = new Map<string, string>(); // userId -> socketId
  private conversationRooms = new Map<string, Set<string>>(); // conversationId -> Set<userId>

  /**
   * Initialiser le serveur WebSocket
   */
  setup(server: any): Server {
    console.log('üåê WebSocket Chat Server - Initialisation...');

    this.io = new Server(server, {
      cors: {
        origin: process.env.FRONTEND_URL || "http://localhost:5173",
        methods: ["GET", "POST"],
        credentials: true
      },
      transports: ['websocket', 'polling']
    });

    this.setupEventHandlers();

    console.log('‚úÖ WebSocket Chat Server - Pr√™t !');
    return this.io;
  }

  /**
   * Configuration des gestionnaires d'√©v√©nements
   */
  private setupEventHandlers(): void {
    if (!this.io) return;

    this.io.on('connection', async (socket: AuthenticatedSocket) => {
      console.log('üîå Nouvelle connexion WebSocket:', socket.id);

      try {
        // Authentification
        const { token, userId } = socket.handshake.auth;
        const user = await this.authenticateUser(token, userId);

        if (!user) {
          console.log('‚ùå Authentification √©chou√©e pour:', socket.id);
          socket.disconnect();
          return;
        }

        // Enrichir le socket avec les infos utilisateur
        socket.userId = user.id;
        socket.userName = user.name;

        // Ajouter l'utilisateur en ligne
        await this.addOnlineUser(socket);

        // Rejoindre les conversations de l'utilisateur
        await this.joinUserConversations(socket);

        // Gestionnaires d'√©v√©nements du socket
        this.setupSocketEvents(socket);

        console.log(`‚úÖ Utilisateur connect√©: ${user.name} (${user.id})`);

      } catch (error) {
        console.error('‚ùå Erreur connexion WebSocket:', error);
        socket.disconnect();
      }
    });
  }

  /**
   * Authentifier un utilisateur via token
   */
  private async authenticateUser(token: string, userId: string): Promise<{ id: string; name: string } | null> {
    try {
      const { data: { user }, error } = await supabaseAdmin.auth.getUser(token);

      if (error || !user || user.id !== userId) {
        return null;
      }

      // R√©cup√©rer le profil utilisateur
      const { data: profile } = await supabaseAdmin
        .from('profiles')
        .select('name')
        .eq('id', userId)
        .single();

      return {
        id: user.id,
        name: profile?.name || 'Utilisateur'
      };

    } catch (error) {
      console.error('‚ùå Erreur authentification WebSocket:', error);
      return null;
    }
  }

  /**
   * Ajouter un utilisateur √† la liste des connect√©s
   */
  private async addOnlineUser(socket: AuthenticatedSocket): Promise<void> {
    if (!socket.userId || !socket.userName) return;

    const onlineUser: OnlineUser = {
      userId: socket.userId,
      userName: socket.userName,
      socketId: socket.id,
      lastSeen: new Date(),
      isTyping: false
    };

    this.onlineUsers.set(socket.userId, onlineUser);
    this.userSockets.set(socket.userId, socket.id);

    // Notifier les autres utilisateurs du statut en ligne
    this.broadcastOnlineStatus(socket.userId, true);
  }

  /**
   * Rejoindre les conversations de l'utilisateur
   */
  private async joinUserConversations(socket: AuthenticatedSocket): Promise<void> {
    if (!socket.userId) return;

    try {
      // R√©cup√©rer les conversations de l'utilisateur
      const { data: conversations } = await supabaseAdmin
        .from('conversations')
        .select('id')
        .or(`participant_1_id.eq.${socket.userId},participant_2_id.eq.${socket.userId}`)
        .eq('status', 'active');

      if (!conversations) return;

      // Rejoindre chaque room de conversation
      for (const conv of conversations) {
        const roomName = `conversation:${conv.id}`;
        socket.join(roomName);

        // Ajouter √† notre tracking des rooms
        if (!this.conversationRooms.has(conv.id)) {
          this.conversationRooms.set(conv.id, new Set());
        }
        this.conversationRooms.get(conv.id)!.add(socket.userId!);

        console.log(`üì• ${socket.userName} rejoint la conversation ${conv.id}`);
      }

    } catch (error) {
      console.error('‚ùå Erreur joinUserConversations:', error);
    }
  }

  /**
   * Configuration des √©v√©nements du socket
   */
  private setupSocketEvents(socket: AuthenticatedSocket): void {
    // ============ GESTION DES CONVERSATIONS ============

    // Rejoindre une conversation sp√©cifique
    socket.on('join_conversation', ({ conversationId }) => {
      if (!socket.userId) return;

      const roomName = `conversation:${conversationId}`;
      socket.join(roomName);

      // Marquer l'utilisateur comme √©tant dans cette conversation
      const user = this.onlineUsers.get(socket.userId);
      if (user) {
        user.currentConversation = conversationId;
        this.onlineUsers.set(socket.userId, user);
      }

      console.log(`üì• ${socket.userName} rejoint la conversation ${conversationId}`);
    });

    // Quitter une conversation
    socket.on('leave_conversation', ({ conversationId }) => {
      if (!socket.userId) return;

      const roomName = `conversation:${conversationId}`;
      socket.leave(roomName);

      // Retirer la conversation courante
      const user = this.onlineUsers.get(socket.userId);
      if (user) {
        user.currentConversation = undefined;
        user.isTyping = false;
        this.onlineUsers.set(socket.userId, user);
      }

      console.log(`üì§ ${socket.userName} quitte la conversation ${conversationId}`);
    });

    // ============ INDICATEURS DE FRAPPE ============

    socket.on('typing', ({ conversationId, isTyping }) => {
      if (!socket.userId || !socket.userName) return;

      // Mettre √† jour le statut de frappe
      const user = this.onlineUsers.get(socket.userId);
      if (user) {
        user.isTyping = isTyping;
        this.onlineUsers.set(socket.userId, user);
      }

      // Broadcaster aux autres participants de la conversation
      socket.to(`conversation:${conversationId}`).emit('user_typing', {
        conversationId,
        userId: socket.userId,
        userName: socket.userName,
        isTyping
      });

      console.log(`‚å®Ô∏è ${socket.userName} ${isTyping ? 'tape' : 'arr√™te de taper'} dans ${conversationId}`);
    });

    // ============ MARQUAGE LU TEMPS R√âEL ============

    socket.on('mark_read', ({ conversationId, messageId }) => {
      if (!socket.userId) return;

      // Broadcaster aux autres participants
      socket.to(`conversation:${conversationId}`).emit('message_read_by_user', {
        userId: socket.userId,
        messageId,
        conversationId,
        readAt: new Date().toISOString()
      });

      console.log(`‚úÖ ${socket.userName} a lu le message ${messageId}`);
    });

    // ============ GESTION DE LA D√âCONNEXION ============

    socket.on('disconnect', (reason) => {
      console.log(`üîå ${socket.userName} d√©connect√©:`, reason);
      this.removeOnlineUser(socket);
    });

    // Heartbeat pour maintenir la connexion
    socket.on('ping', () => {
      if (socket.userId) {
        const user = this.onlineUsers.get(socket.userId);
        if (user) {
          user.lastSeen = new Date();
          this.onlineUsers.set(socket.userId, user);
        }
      }
      socket.emit('pong');
    });
  }

  /**
   * Retirer un utilisateur de la liste des connect√©s
   */
  private removeOnlineUser(socket: AuthenticatedSocket): void {
    if (!socket.userId) return;

    this.onlineUsers.delete(socket.userId);
    this.userSockets.delete(socket.userId);

    // Retirer des rooms de conversation
    for (const [conversationId, userSet] of this.conversationRooms) {
      userSet.delete(socket.userId);
      if (userSet.size === 0) {
        this.conversationRooms.delete(conversationId);
      }
    }

    // Notifier les autres du statut hors ligne
    this.broadcastOnlineStatus(socket.userId, false);
  }

  // ============ M√âTHODES PUBLIQUES POUR LE CHAT SERVICE ============

  /**
   * Notifier un nouveau message
   */
  notifyNewMessage(conversationId: string, message: Message, excludeUserId?: string): void {
    if (!this.io) return;

    console.log('üì® Notification nouveau message:', message.id);

    const eventData = {
      conversationId,
      message,
      timestamp: new Date().toISOString()
    };

    // Envoyer √† tous les participants sauf l'exp√©diteur
    if (excludeUserId) {
      this.io.to(`conversation:${conversationId}`).except(this.userSockets.get(excludeUserId) || '').emit('new_message', eventData);
    } else {
      this.io.to(`conversation:${conversationId}`).emit('new_message', eventData);
    }
  }

  /**
   * Notifier une modification de message
   */
  notifyMessageUpdate(conversationId: string, message: Message): void {
    if (!this.io) return;

    console.log('‚úèÔ∏è Notification message modifi√©:', message.id);

    this.io.to(`conversation:${conversationId}`).emit('message_updated', {
      conversationId,
      message,
      timestamp: new Date().toISOString()
    });
  }

  /**
   * Notifier une suppression de message
   */
  notifyMessageDeleted(conversationId: string, messageId: string): void {
    if (!this.io) return;

    console.log('üóëÔ∏è Notification message supprim√©:', messageId);

    this.io.to(`conversation:${conversationId}`).emit('message_deleted', {
      conversationId,
      messageId,
      timestamp: new Date().toISOString()
    });
  }

  /**
   * Notifier une r√©action
   */
  notifyMessageReaction(conversationId: string, messageId: string, emoji: string, action: 'add' | 'remove', userId: string): void {
    if (!this.io) return;

    console.log('üòä Notification r√©action:', { messageId, emoji, action });

    // Envoyer √† tous sauf celui qui a r√©agi
    this.io.to(`conversation:${conversationId}`).except(this.userSockets.get(userId) || '').emit('message_reaction', {
      conversationId,
      messageId,
      emoji,
      action,
      userId,
      timestamp: new Date().toISOString()
    });
  }

  /**
   * Notifier une nouvelle conversation
   */
  notifyNewConversation(participantIds: string[], conversation: Conversation): void {
    if (!this.io) return;

    console.log('üí¨ Notification nouvelle conversation:', conversation.id);

    // Cr√©er la room pour cette conversation
    const roomName = `conversation:${conversation.id}`;

    // Faire rejoindre les participants
    for (const userId of participantIds) {
      const socketId = this.userSockets.get(userId);
      if (socketId) {
        const socket = this.io.sockets.sockets.get(socketId);
        if (socket) {
          socket.join(roomName);
        }

        // Envoyer la notification
        this.io.to(socketId).emit('new_conversation', {
          conversation,
          timestamp: new Date().toISOString()
        });
      }
    }
  }

  /**
   * Broadcaster le statut en ligne d'un utilisateur
   */
  private broadcastOnlineStatus(userId: string, isOnline: boolean): void {
    if (!this.io) return;

    // R√©cup√©rer les conversations de cet utilisateur pour notifier les bonnes personnes
    // Pour simplifier, on broadcast √† tous les utilisateurs connect√©s
    // TODO: Optimiser pour ne notifier que les contacts
    this.io.emit('user_online', {
      userId,
      isOnline,
      lastSeen: new Date().toISOString()
    });

    console.log(`üì° Statut ${isOnline ? 'en ligne' : 'hors ligne'} brodcast√© pour ${userId}`);
  }

  /**
   * Obtenir les utilisateurs en ligne
   */
  getOnlineUsers(): OnlineUser[] {
    return Array.from(this.onlineUsers.values());
  }

  /**
   * V√©rifier si un utilisateur est en ligne
   */
  isUserOnline(userId: string): boolean {
    return this.onlineUsers.has(userId);
  }

  /**
   * Obtenir les statistiques du serveur
   */
  getServerStats() {
    return {
      connectedUsers: this.onlineUsers.size,
      activeConversations: this.conversationRooms.size,
      totalSockets: this.io?.sockets.sockets.size || 0
    };
  }

  /**
   * Nettoyage p√©riodique des utilisateurs inactifs
   */
  startCleanupTask(): void {
    setInterval(() => {
      const now = new Date();
      const maxInactivity = 5 * 60 * 1000; // 5 minutes

      for (const [userId, user] of this.onlineUsers) {
        if (now.getTime() - user.lastSeen.getTime() > maxInactivity) {
          console.log(`üßπ Nettoyage utilisateur inactif: ${user.userName}`);

          // Simuler une d√©connexion
          const socketId = this.userSockets.get(userId);
          if (socketId) {
            const socket = this.io?.sockets.sockets.get(socketId);
            if (socket) {
              socket.disconnect();
            }
          }
        }
      }
    }, 60000); // Toutes les minutes
  }
}

// Instance singleton
export const chatWebSocketServer = new ChatWebSocketServer();

/**
 * Fonction d'initialisation pour server.ts
 */
export const setupWebSocket = (server: any): Server => {
  const io = chatWebSocketServer.setup(server);

  // D√©marrer la t√¢che de nettoyage
  chatWebSocketServer.startCleanupTask();

  return io;
};

export default setupWebSocket;// =============================================


--- - ---

// INDEX EXPORT - backend/src/modules/chat/index.ts
// =============================================

export { chatService } from './chat.service';
export { chatController } from './chat.controller';
export { default as chatRoutes } from './chat.routes';

export type {
  Conversation,
  Message,
  MessageRead,
  CreateConversationParams,
  SendMessageParams,
  UpdateMessageParams,
  ReactToMessageParams
} from './chat.service';// =============================================


--- - ---

// PAGE CHAT MOBILE-OPTIMIS√âE - frontend/src/components/chat/ChatPage.tsx
// =============================================

import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useAuth } from '../../contexts/AuthContext';
import { useChat } from '../../hooks/useChat';
import { ConversationList } from './ConversationList';
import { ChatWindow } from './ChatWindow';
import { MessageCircle, Users, ArrowLeft } from 'lucide-react';

interface ChatPageProps {
  isDarkMode: boolean;
}

export const ChatPage: React.FC<ChatPageProps> = ({ isDarkMode }) => {
  const { user } = useAuth();
  const navigate = useNavigate();
  const { conversationId } = useParams<{ conversationId?: string }>();

  const {
    conversations,
    currentConversation,
    messages,
    chatStats,
    isLoading,
    isLoadingMessages,
    selectConversation,
    sendMessage,
    reactToMessage,
    deleteMessage,
    refreshConversations
  } = useChat();

  const [isMobileView, setIsMobileView] = useState(false);
  const [showConversationList, setShowConversationList] = useState(true);

  // D√©tection mobile am√©lior√©e
  useEffect(() => {
    const checkMobile = () => {
      const isMobile = window.innerWidth <= 768;
      setIsMobileView(isMobile);

      // Sur mobile : afficher la liste si pas de conversation active
      if (isMobile) {
        setShowConversationList(!currentConversation);
      } else {
        // Sur desktop : toujours afficher la liste
        setShowConversationList(true);
      }
    };

    checkMobile();
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, [currentConversation]);

  // Navigation par URL
  useEffect(() => {
    if (conversationId && conversations.length > 0) {
      const conv = conversations.find(c => c.id === conversationId);
      if (conv && conv.id !== currentConversation?.id) {
        selectConversation(conv);
        // Sur mobile, masquer la liste quand on s√©lectionne une conversation
        if (isMobileView) {
          setShowConversationList(false);
        }
      }
    }
  }, [conversationId, conversations, currentConversation, selectConversation, isMobileView]);

  // Gestion des actions
  const handleSelectConversation = (conversation: any) => {
    selectConversation(conversation);
    navigate(`/chat/${conversation.id}`);

    // Sur mobile, masquer la liste des conversations
    if (isMobileView) {
      setShowConversationList(false);
    }
  };

  const handleSendMessage = async (content: string, replyToId?: string) => {
    if (!currentConversation || !content.trim()) return;

    try {
      await sendMessage(currentConversation.id, {
        content: content.trim(),
        reply_to_id: replyToId
      });
    } catch (error) {
      console.error('‚ùå Erreur envoi message:', error);
      // TODO: Afficher une notification d'erreur
    }
  };

  const handleBackToList = () => {
    setShowConversationList(true);
    navigate('/chat');
  };

  if (isLoading) {
    return (
      <div className={`min-h-screen ${isDarkMode ? 'bg-gray-900' : 'bg-gray-50'} flex items-center justify-center`}>
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-purple-500 mx-auto mb-4"></div>
          <p className={`text-lg ${isDarkMode ? 'text-gray-300' : 'text-gray-600'}`}>
            Chargement de vos conversations...
          </p>
        </div>
      </div>
    );
  }

  return (
    <div className={`min-h-screen ${isDarkMode ? 'bg-gray-900' : 'bg-gray-50'}`}>
      {/* Header mobile pour le chat */}
      {isMobileView && !showConversationList && currentConversation && (
        <div className={`sticky top-16 z-40 px-4 py-3 border-b ${
          isDarkMode ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'
        } shadow-sm`}>
          <div className="flex items-center gap-3">
            <button
              onClick={handleBackToList}
              className={`p-2 rounded-lg transition-colors ${
                isDarkMode
                  ? 'text-gray-300 hover:text-white hover:bg-gray-700'
                  : 'text-gray-600 hover:text-gray-900 hover:bg-gray-100'
              }`}
            >
              <ArrowLeft className="w-5 h-5" />
            </button>

            {/* Info conversation */}
            <div className="flex items-center gap-3 flex-1">
              {currentConversation.other_participant?.avatar_url ? (
                <img
                  src={currentConversation.other_participant.avatar_url}
                  alt={currentConversation.other_participant.name}
                  className="w-8 h-8 rounded-full object-cover"
                />
              ) : (
                <div className="w-8 h-8 rounded-full bg-gradient-to-br from-purple-500 to-pink-500 flex items-center justify-center">
                  <span className="text-white font-bold text-sm">
                    {currentConversation.other_participant?.name?.charAt(0).toUpperCase() || '?'}
                  </span>
                </div>
              )}

              <div className="flex-1 min-w-0">
                <h3 className={`font-semibold truncate ${isDarkMode ? 'text-white' : 'text-gray-900'}`}>
                  {currentConversation.other_participant?.name || 'Utilisateur'}
                </h3>
                <p className={`text-xs ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}>
                  En ligne
                </p>
              </div>
            </div>
          </div>
        </div>
      )}

      <div className={`${isMobileView ? 'h-screen' : 'max-w-7xl mx-auto h-screen'} flex`}>

        {/* Liste des conversations */}
        <div className={`
          ${isMobileView
            ? showConversationList ? 'w-full' : 'hidden'
            : 'w-1/3 min-w-[350px]'
          }
          ${!isMobileView ? 'border-r' : ''}
          ${isDarkMode ? 'border-gray-700' : 'border-gray-200'}
          ${isMobileView ? (showConversationList ? 'pt-0' : 'pt-16') : ''}
        `}>
          <ConversationList
            conversations={conversations}
            currentConversation={currentConversation}
            onSelectConversation={handleSelectConversation}
            isDarkMode={isDarkMode}
            chatStats={chatStats}
            isLoading={isLoading}
            onRefresh={refreshConversations}
            isMobile={isMobileView}
          />
        </div>

        {/* Zone de chat */}
        <div className={`
          ${isMobileView
            ? showConversationList ? 'hidden' : 'w-full'
            : 'flex-1'
          }
          flex flex-col
          ${isMobileView && !showConversationList ? 'pt-0' : ''}
        `}>
          {currentConversation ? (
            <ChatWindow
              conversation={currentConversation}
              messages={messages}
              isLoadingMessages={isLoadingMessages}
              onSendMessage={handleSendMessage}
              onReactToMessage={reactToMessage}
              onDeleteMessage={deleteMessage}
              onBackToList={isMobileView ? handleBackToList : undefined}
              isDarkMode={isDarkMode}
              isMobile={isMobileView}
            />
          ) : (
            // √âtat vide - Pas de conversation s√©lectionn√©e (desktop seulement)
            !isMobileView && (
              <div className="flex-1 flex items-center justify-center">
                <div className="text-center max-w-md mx-auto p-8">
                  <div className="w-20 h-20 mx-auto mb-6 rounded-full bg-gradient-to-br from-purple-500 to-pink-500 flex items-center justify-center">
                    <MessageCircle className="w-10 h-10 text-white" />
                  </div>

                  <h3 className={`text-2xl font-bold mb-4 ${isDarkMode ? 'text-white' : 'text-gray-900'}`}>
                    S√©lectionnez une conversation
                  </h3>

                  <p className={`text-lg mb-6 ${isDarkMode ? 'text-gray-300' : 'text-gray-600'}`}>
                    Choisissez une conversation pour commencer √† discuter
                  </p>

                  {conversations.length === 0 && (
                    <div className={`rounded-lg p-6 ${isDarkMode ? 'bg-gray-800/50' : 'bg-white/50'} border ${isDarkMode ? 'border-gray-700' : 'border-gray-200'}`}>
                      <Users className={`w-12 h-12 mx-auto mb-4 ${isDarkMode ? 'text-gray-400' : 'text-gray-500'}`} />
                      <h4 className={`text-lg font-semibold mb-2 ${isDarkMode ? 'text-white' : 'text-gray-900'}`}>
                        Aucune conversation
                      </h4>
                      <p className={`text-sm mb-4 ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}>
                        Les conversations se cr√©ent automatiquement quand quelqu'un accepte votre demande de miroir !
                      </p>
                      <button
                        onClick={() => navigate('/decouverte')}
                        className="px-6 py-3 bg-gradient-to-r from-purple-600 to-pink-600 text-white rounded-lg hover:shadow-lg transition-all duration-200 font-medium"
                      >
                        üîç D√©couvrir des profils
                      </button>
                    </div>
                  )}
                </div>
              </div>
            )
          )}
        </div>
      </div>
    </div>
  );
};// =============================================


--- - ---

// COMPOSANT TEST CHAT - frontend/src/components/chat/ChatTest.tsx
// =============================================

import React from 'react';
import { useChat } from '../../hooks/useChat';

interface ChatTestProps {
  isDarkMode: boolean;
}

export const ChatTest: React.FC<ChatTestProps> = ({ isDarkMode }) => {
  const {
    conversations,
    currentConversation,
    messages,
    chatStats,
    isLoading,
    isLoadingMessages,
    selectConversation,
    sendMessage,
    refreshConversations
  } = useChat();

  const handleSendTestMessage = async () => {
    if (!currentConversation) return;

    try {
      await sendMessage(currentConversation.id, {
        content: 'Message de test depuis l\'interface ! üöÄ'
      });
    } catch (error) {
      console.error('Erreur envoi message test:', error);
    }
  };

  return (
    <div className={`min-h-screen p-6 ${isDarkMode ? 'bg-gray-900 text-white' : 'bg-gray-50 text-gray-900'}`}>
      <div className="max-w-6xl mx-auto">

        {/* Header */}
        <div className="mb-6">
          <h1 className="text-3xl font-bold mb-2">üß™ Test Chat System</h1>
          <p className="text-sm opacity-75">
            Test des services backend et frontend
          </p>
        </div>

        {/* Stats */}
        <div className={`rounded-lg p-4 mb-6 ${isDarkMode ? 'bg-gray-800' : 'bg-white'}`}>
          <h2 className="text-lg font-semibold mb-2">üìä Statistiques</h2>
          <div className="grid grid-cols-3 gap-4 text-center">
            <div>
              <div className="text-2xl font-bold text-purple-500">{conversations.length}</div>
              <div className="text-sm">Conversations</div>
            </div>
            <div>
              <div className="text-2xl font-bold text-blue-500">{chatStats.total_unread_conversations}</div>
              <div className="text-sm">Non lues</div>
            </div>
            <div>
              <div className="text-2xl font-bold text-green-500">{messages.length}</div>
              <div className="text-sm">Messages</div>
            </div>
          </div>

          <button
            onClick={refreshConversations}
            disabled={isLoading}
            className="mt-4 px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 disabled:opacity-50"
          >
            {isLoading ? 'Chargement...' : 'üîÑ Actualiser'}
          </button>
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">

          {/* Liste des conversations */}
          <div className={`rounded-lg p-4 ${isDarkMode ? 'bg-gray-800' : 'bg-white'}`}>
            <h2 className="text-lg font-semibold mb-4">üí¨ Conversations</h2>

            {isLoading ? (
              <div className="text-center py-4">
                <div className="animate-spin w-6 h-6 border-2 border-purple-500 border-t-transparent rounded-full mx-auto"></div>
                <p className="mt-2 text-sm">Chargement...</p>
              </div>
            ) : conversations.length === 0 ? (
              <div className="text-center py-8">
                <div className="text-4xl mb-2">üí≠</div>
                <p className="text-sm opacity-75">Aucune conversation</p>
                <p className="text-xs mt-1 opacity-50">
                  Les conversations se cr√©ent automatiquement quand un miroir est accept√© !
                </p>
              </div>
            ) : (
              <div className="space-y-2">
                {conversations.map((conv) => (
                  <button
                    key={conv.id}
                    onClick={() => selectConversation(conv)}
                    className={`w-full text-left p-3 rounded-lg transition-colors ${
                      currentConversation?.id === conv.id
                        ? 'bg-purple-600 text-white'
                        : isDarkMode
                          ? 'hover:bg-gray-700'
                          : 'hover:bg-gray-100'
                    }`}
                  >
                    <div className="flex items-center justify-between">
                      <div className="flex items-center gap-3">
                        {/* Avatar */}
                        {conv.other_participant?.avatar_url ? (
                          <img
                            src={conv.other_participant.avatar_url}
                            alt={conv.other_participant.name}
                            className="w-8 h-8 rounded-full"
                          />
                        ) : (
                          <div className="w-8 h-8 rounded-full bg-gradient-to-r from-purple-500 to-pink-500 flex items-center justify-center text-white text-sm font-bold">
                            {conv.other_participant?.name?.charAt(0) || '?'}
                          </div>
                        )}

                        {/* Info */}
                        <div>
                          <div className="font-medium">
                            {conv.other_participant?.name || 'Utilisateur'}
                          </div>
                          <div className="text-xs opacity-75">
                            {conv.last_message ?
                              (conv.last_message.content?.substring(0, 30) + '...' || 'Message') :
                              'Nouvelle conversation'
                            }
                          </div>
                        </div>
                      </div>

                      {/* Badge non lu */}
                      {(conv.unread_count || 0) > 0 && (
                        <span className="bg-red-500 text-white text-xs px-2 py-1 rounded-full">
                          {conv.unread_count}
                        </span>
                      )}
                    </div>
                  </button>
                ))}
              </div>
            )}
          </div>

          {/* Messages */}
          <div className={`rounded-lg p-4 ${isDarkMode ? 'bg-gray-800' : 'bg-white'}`}>
            <h2 className="text-lg font-semibold mb-4">
              üì® Messages
              {currentConversation && (
                <span className="text-sm font-normal ml-2">
                  avec {currentConversation.other_participant?.name}
                </span>
              )}
            </h2>

            {!currentConversation ? (
              <div className="text-center py-8">
                <div className="text-4xl mb-2">üëÜ</div>
                <p className="text-sm opacity-75">
                  S√©lectionnez une conversation
                </p>
              </div>
            ) : isLoadingMessages ? (
              <div className="text-center py-4">
                <div className="animate-spin w-6 h-6 border-2 border-purple-500 border-t-transparent rounded-full mx-auto"></div>
                <p className="mt-2 text-sm">Chargement des messages...</p>
              </div>
            ) : (
              <div>
                {/* Liste des messages */}
                <div className="space-y-3 mb-4 max-h-64 overflow-y-auto">
                  {messages.length === 0 ? (
                    <div className="text-center py-4">
                      <p className="text-sm opacity-75">Aucun message</p>
                    </div>
                  ) : (
                    messages.map((message) => (
                      <div
                        key={message.id}
                        className={`flex ${message.is_own_message ? 'justify-end' : 'justify-start'}`}
                      >
                        <div
                          className={`max-w-xs px-4 py-2 rounded-lg ${
                            message.is_own_message
                              ? 'bg-purple-600 text-white'
                              : isDarkMode
                                ? 'bg-gray-700 text-white'
                                : 'bg-gray-200 text-gray-900'
                          }`}
                        >
                          {message.message_type === 'system' ? (
                            <div className="text-center text-sm opacity-75">
                              {message.content}
                            </div>
                          ) : (
                            <div>
                              <div className="text-sm">{message.content}</div>
                              <div className="text-xs opacity-75 mt-1">
                                {new Date(message.created_at).toLocaleTimeString('fr-FR', {
                                  hour: '2-digit',
                                  minute: '2-digit'
                                })}
                              </div>
                            </div>
                          )}
                        </div>
                      </div>
                    ))
                  )}
                </div>

                {/* Bouton test */}
                <button
                  onClick={handleSendTestMessage}
                  className="w-full px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700"
                >
                  üöÄ Envoyer message test
                </button>
              </div>
            )}
          </div>
        </div>

        {/* Debug info */}
        <div className={`mt-6 p-4 rounded-lg text-xs ${isDarkMode ? 'bg-gray-800' : 'bg-gray-100'}`}>
          <h3 className="font-semibold mb-2">üîç Debug Info</h3>
          <div className="grid grid-cols-2 gap-4">
            <div>
              <div>Conversations: {conversations.length}</div>
              <div>Messages: {messages.length}</div>
              <div>Loading: {isLoading ? 'Oui' : 'Non'}</div>
            </div>
            <div>
              <div>Conversation actuelle: {currentConversation?.id || 'Aucune'}</div>
              <div>Unread total: {chatStats.total_unread_conversations}</div>
              <div>Messages loading: {isLoadingMessages ? 'Oui' : 'Non'}</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};// =============================================


--- - ---

// FEN√äTRE DE CHAT MOBILE - frontend/src/components/chat/ChatWindow.tsx
// =============================================

import React, { useState, useRef, useEffect } from 'react';
import { ArrowLeft, Phone, Video, MoreVertical, Smile, Paperclip, Send, Loader2 } from 'lucide-react';
import { MessageList } from './MessageList';
import { MessageInput } from './MessageInput';
import type { Conversation, Message } from '../../../../shared/types/chat';

interface ChatWindowProps {
  conversation: Conversation;
  messages: Message[];
  isLoadingMessages: boolean;
  onSendMessage: (content: string, replyToId?: string) => void;
  onReactToMessage: (messageId: string, emoji: string) => void;
  onDeleteMessage: (messageId: string) => void;
  onBackToList?: () => void; // Pour mobile
  isDarkMode: boolean;
  isMobile?: boolean;
}

export const ChatWindow: React.FC<ChatWindowProps> = ({
  conversation,
  messages,
  isLoadingMessages,
  onSendMessage,
  onReactToMessage,
  onDeleteMessage,
  onBackToList,
  isDarkMode,
  isMobile = false
}) => {
  const [showUserInfo, setShowUserInfo] = useState(false);
  const [isTyping, setIsTyping] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  // Auto-scroll vers le bas quand de nouveaux messages arrivent
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  const handleSendMessage = (content: string, replyToId?: string) => {
    onSendMessage(content, replyToId);
  };

  return (
    <div className="flex flex-col h-full">

      {/* Header de la conversation (masqu√© sur mobile si header s√©par√©) */}
      {!isMobile && (
        <div className={`px-4 sm:px-6 py-4 border-b ${isDarkMode ? 'border-gray-700 bg-gray-800' : 'border-gray-200 bg-white'} shadow-sm`}>
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-3">

              {/* Bouton retour (mobile) */}
              {onBackToList && (
                <button
                  onClick={onBackToList}
                  className={`p-2 rounded-lg transition-colors lg:hidden ${
                    isDarkMode
                      ? 'hover:bg-gray-700 text-gray-300'
                      : 'hover:bg-gray-100 text-gray-600'
                  }`}
                >
                  <ArrowLeft className="w-5 h-5" />
                </button>
              )}

              {/* Avatar et info utilisateur */}
              <button
                onClick={() => setShowUserInfo(!showUserInfo)}
                className="flex items-center space-x-3 hover:opacity-80 transition-opacity"
              >
                {conversation.other_participant?.avatar_url ? (
                  <img
                    src={conversation.other_participant.avatar_url}
                    alt={conversation.other_participant.name}
                    className="w-10 h-10 rounded-full object-cover ring-2 ring-purple-500/20"
                  />
                ) : (
                  <div className="w-10 h-10 rounded-full bg-gradient-to-br from-purple-500 to-pink-500 flex items-center justify-center ring-2 ring-purple-500/20">
                    <span className="text-white font-bold">
                      {conversation.other_participant?.name?.charAt(0).toUpperCase() || '?'}
                    </span>
                  </div>
                )}

                <div className="text-left">
                  <h3 className={`font-semibold ${isDarkMode ? 'text-white' : 'text-gray-900'}`}>
                    {conversation.other_participant?.name || 'Utilisateur'}
                  </h3>
                  <p className={`text-sm ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}>
                    {isTyping ? (
                      <span className="flex items-center">
                        <span className="animate-pulse">En train d'√©crire</span>
                        <span className="flex space-x-1 ml-2">
                          <div className="w-1 h-1 bg-purple-500 rounded-full animate-bounce"></div>
                          <div className="w-1 h-1 bg-purple-500 rounded-full animate-bounce" style={{ animationDelay: '0.1s' }}></div>
                          <div className="w-1 h-1 bg-purple-500 rounded-full animate-bounce" style={{ animationDelay: '0.2s' }}></div>
                        </span>
                      </span>
                    ) : (
                      'En ligne' // Placeholder - √† connecter avec le statut r√©el
                    )}
                  </p>
                </div>
              </button>
            </div>

            {/* Actions header */}
            <div className="flex items-center space-x-2">
              {/* Appel vocal (placeholder) */}
              <button
                className={`p-2 rounded-lg transition-colors ${
                  isDarkMode
                    ? 'hover:bg-gray-700 text-gray-300'
                    : 'hover:bg-gray-100 text-gray-600'
                }`}
                title="Appel vocal"
              >
                <Phone className="w-5 h-5" />
              </button>

              {/* Appel vid√©o (placeholder) */}
              <button
                className={`p-2 rounded-lg transition-colors ${
                  isDarkMode
                    ? 'hover:bg-gray-700 text-gray-300'
                    : 'hover:bg-gray-100 text-gray-600'
                }`}
                title="Appel vid√©o"
              >
                <Video className="w-5 h-5" />
              </button>

              {/* Menu options */}
              <button
                className={`p-2 rounded-lg transition-colors ${
                  isDarkMode
                    ? 'hover:bg-gray-700 text-gray-300'
                    : 'hover:bg-gray-100 text-gray-600'
                }`}
                title="Plus d'options"
              >
                <MoreVertical className="w-5 h-5" />
              </button>
            </div>
          </div>

          {/* Info panel utilisateur (collapsible) */}
          {showUserInfo && (
            <div className={`mt-4 p-4 rounded-lg ${isDarkMode ? 'bg-gray-700/50' : 'bg-gray-50'} border ${isDarkMode ? 'border-gray-600' : 'border-gray-200'}`}>
              <div className="text-center">
                <h4 className={`font-semibold mb-2 ${isDarkMode ? 'text-white' : 'text-gray-900'}`}>
                  {conversation.other_participant?.name || 'Utilisateur'}
                </h4>
                <p className={`text-sm ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}>
                  Conversation cr√©√©e le {new Date(conversation.created_at).toLocaleDateString('fr-FR', {
                    day: 'numeric',
                    month: 'long',
                    year: 'numeric'
                  })}
                </p>
                <div className="flex justify-center space-x-2 mt-4">
                  <button className="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors text-sm">
                    Voir le profil
                  </button>
                  <button className={`px-4 py-2 rounded-lg transition-colors text-sm ${
                    isDarkMode
                      ? 'bg-gray-600 text-white hover:bg-gray-500'
                      : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                  }`}>
                    Bloquer
                  </button>
                </div>
              </div>
            </div>
          )}
        </div>
      )}

      {/* Zone des messages */}
      <div className={`flex-1 overflow-hidden ${isMobile ? 'pb-safe' : ''}`}>
        {isLoadingMessages ? (
          <div className="flex items-center justify-center h-full">
            <div className="text-center">
              <Loader2 className="w-8 h-8 animate-spin text-purple-500 mx-auto mb-4" />
              <p className={`text-sm ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}>
                Chargement des messages...
              </p>
            </div>
          </div>
        ) : (
          <div className="h-full">
            <MessageList
              messages={messages}
              isLoading={false}
              onReactToMessage={onReactToMessage}
              onDeleteMessage={onDeleteMessage}
              isDarkMode={isDarkMode}
              isMobile={isMobile}
            />
            <div ref={messagesEndRef} />
          </div>
        )}
      </div>

      {/* Zone de saisie */}
      <div className={`border-t ${isDarkMode ? 'border-gray-700' : 'border-gray-200'} ${isMobile ? 'pb-safe' : ''}`}>
        <MessageInput
          onSendMessage={handleSendMessage}
          isDarkMode={isDarkMode}
          disabled={isLoadingMessages}
          placeholder="Tapez votre message..."
          isMobile={isMobile}
        />
      </div>
    </div>
  );
};// =============================================


--- - ---

// LISTE DES CONVERSATIONS MOBILE - frontend/src/components/chat/ConversationList.tsx
// ‚úÖ VERSION CORRIG√âE - ERREURS REACT FIXES
// =============================================

import React, { useState } from 'react';
import { Search, MoreVertical, RefreshCw, MessageCircle, Clock, ArrowLeft } from 'lucide-react';
import { chatService } from '../../services/chatService';
import type { Conversation, ChatStats } from '../../../../shared/types/chat';

interface ConversationListProps {
  conversations: Conversation[];
  currentConversation: Conversation | null;
  onSelectConversation: (conversation: Conversation) => void;
  isDarkMode: boolean;
  chatStats: ChatStats;
  isLoading: boolean;
  onRefresh: () => void;
  isMobile?: boolean;
}

export const ConversationList: React.FC<ConversationListProps> = ({
  conversations,
  currentConversation,
  onSelectConversation,
  isDarkMode,
  chatStats,
  isLoading,
  onRefresh,
  isMobile = false
}) => {
  const [searchQuery, setSearchQuery] = useState('');
  const [isRefreshing, setIsRefreshing] = useState(false);

  // Filtrer les conversations par recherche
  const filteredConversations = conversations.filter(conv =>
    conv.other_participant?.name?.toLowerCase().includes(searchQuery.toLowerCase()) ||
    (conv.last_message?.content && conv.last_message.content.toLowerCase().includes(searchQuery.toLowerCase()))
  );

  const handleRefresh = async () => {
    setIsRefreshing(true);
    await onRefresh();
    setTimeout(() => setIsRefreshing(false), 500);
  };

  const formatLastMessageTime = (dateString: string) => {
    const date = new Date(dateString);
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMins / 60);
    const diffDays = Math.floor(diffHours / 24);

    if (diffMins < 1) return 'maintenant';
    if (diffMins < 60) return `${diffMins}min`;
    if (diffHours < 24) return `${diffHours}h`;
    if (diffDays < 7) return `${diffDays}j`;

    return date.toLocaleDateString('fr-FR', {
      day: 'numeric',
      month: 'short'
    });
  };

  const getLastMessagePreview = (conversation: Conversation) => {
    if (!conversation.last_message) return 'Nouvelle conversation';

    const msg = conversation.last_message;
    if (msg.message_type === 'system') return msg.content || 'Message syst√®me';
    if (msg.message_type === 'image') return 'üì∑ Image';
    if (msg.message_type === 'voice') return 'üéµ Message vocal';

    const content = msg.content || '';
    return content.length > (isMobile ? 35 : 40) ? content.substring(0, isMobile ? 35 : 40) + '...' : content;
  };

  return (
    <div className={`h-full flex flex-col ${isDarkMode ? 'bg-gray-800' : 'bg-white'}`}>

      {/* Header */}
      <div className={`${isMobile ? 'p-3' : 'p-4'} border-b ${isDarkMode ? 'border-gray-700' : 'border-gray-200'}`}>
        <div className="flex items-center justify-between mb-4">
          <div>
            <h2 className={`${isMobile ? 'text-lg' : 'text-xl'} font-bold ${isDarkMode ? 'text-white' : 'text-gray-900'}`}>
              Messages
            </h2>
            <p className={`text-xs ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}>
              {conversations.length} conversation{conversations.length !== 1 ? 's' : ''}
              {chatStats.total_unread_conversations > 0 && (
                <span className="ml-2 px-2 py-0.5 bg-red-500 text-white text-xs rounded-full">
                  {chatStats.total_unread_conversations} non lue{chatStats.total_unread_conversations !== 1 ? 's' : ''}
                </span>
              )}
            </p>
          </div>

          {/* ‚úÖ CORRECTION : Button au lieu de div */}
          <button
            onClick={handleRefresh}
            disabled={isLoading || isRefreshing}
            className={`p-2 rounded-lg transition-all duration-200 ${
              isDarkMode
                ? 'hover:bg-gray-700 text-gray-300'
                : 'hover:bg-gray-100 text-gray-600'
            } ${(isLoading || isRefreshing) ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}`}
            title="Actualiser"
          >
            <RefreshCw className={`${isMobile ? 'w-4 h-4' : 'w-5 h-5'} ${isRefreshing ? 'animate-spin' : ''}`} />
          </button>
        </div>

        {/* Barre de recherche */}
        <div className="relative">
          <Search className={`absolute left-3 top-1/2 transform -translate-y-1/2 ${isMobile ? 'w-3.5 h-3.5' : 'w-4 h-4'} ${
            isDarkMode ? 'text-gray-400' : 'text-gray-500'
          }`} />
          <input
            type="text"
            placeholder="Rechercher une conversation..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className={`w-full ${isMobile ? 'pl-9 pr-3 py-2.5 text-sm' : 'pl-10 pr-4 py-2'} rounded-lg border transition-colors ${
              isDarkMode
                ? 'bg-gray-700 border-gray-600 text-white placeholder-gray-400 focus:border-purple-500'
                : 'bg-gray-50 border-gray-300 text-gray-900 placeholder-gray-500 focus:border-purple-500'
            } focus:outline-none focus:ring-2 focus:ring-purple-500/20`}
          />
        </div>
      </div>

      {/* Liste des conversations */}
      <div className="flex-1 overflow-y-auto">
        {isLoading ? (
          <div className="p-6 text-center">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-purple-500 mx-auto mb-4"></div>
            <p className={`text-sm ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}>
              Chargement des conversations...
            </p>
          </div>
        ) : filteredConversations.length === 0 ? (
          <div className="p-6 text-center">
            {conversations.length === 0 ? (
              // Aucune conversation
              <div className="space-y-4">
                <div className="w-16 h-16 mx-auto rounded-full bg-gradient-to-br from-purple-500/20 to-pink-500/20 flex items-center justify-center">
                  <MessageCircle className={`w-8 h-8 ${isDarkMode ? 'text-gray-500' : 'text-gray-400'}`} />
                </div>
                <div>
                  <h3 className={`text-lg font-semibold mb-2 ${isDarkMode ? 'text-white' : 'text-gray-900'}`}>
                    Aucune conversation
                  </h3>
                  <p className={`text-sm ${isDarkMode ? 'text-gray-400' : 'text-gray-600'} ${isMobile ? 'px-4' : ''}`}>
                    Les conversations se cr√©ent automatiquement quand quelqu'un accepte votre demande de miroir !
                  </p>
                </div>
              </div>
            ) : (
              // Pas de r√©sultats de recherche
              <div className="space-y-4">
                <Search className={`w-12 h-12 mx-auto ${isDarkMode ? 'text-gray-500' : 'text-gray-400'}`} />
                <div>
                  <h3 className={`text-lg font-semibold mb-2 ${isDarkMode ? 'text-white' : 'text-gray-900'}`}>
                    Aucun r√©sultat
                  </h3>
                  <p className={`text-sm ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}>
                    Aucune conversation ne correspond √† "{searchQuery}"
                  </p>
                </div>
              </div>
            )}
          </div>
        ) : (
          <div className={isMobile ? 'space-y-0' : 'space-y-1'}>
            {filteredConversations.map((conversation) => (
              <button
                key={conversation.id}
                onClick={() => onSelectConversation(conversation)}
                className={`w-full text-left ${isMobile ? 'p-3' : 'p-4'} transition-all duration-200 border-l-4 ${
                  isMobile ? 'active:scale-[0.98]' : 'hover:scale-[1.02]'
                } ${
                  currentConversation?.id === conversation.id
                    ? `border-l-purple-500 ${
                        isDarkMode
                          ? 'bg-purple-900/30 shadow-lg shadow-purple-900/20'
                          : 'bg-purple-50 shadow-lg shadow-purple-500/10'
                      }`
                    : `border-l-transparent ${
                        isDarkMode
                          ? 'hover:bg-gray-700/50 active:bg-gray-700/70'
                          : 'hover:bg-gray-50 active:bg-gray-100'
                      }`
                }`}
              >
                <div className="flex items-center space-x-3">
                  {/* Avatar */}
                  <div className="relative flex-shrink-0">
                    {conversation.other_participant?.avatar_url ? (
                      <img
                        src={conversation.other_participant.avatar_url}
                        alt={conversation.other_participant.name}
                        className={`${isMobile ? 'w-10 h-10' : 'w-12 h-12'} rounded-full object-cover ring-2 ring-white/10`}
                      />
                    ) : (
                      <div className={`${isMobile ? 'w-10 h-10' : 'w-12 h-12'} rounded-full bg-gradient-to-br from-purple-500 to-pink-500 flex items-center justify-center ring-2 ring-white/10`}>
                        <span className="text-white font-bold text-lg">
                          {conversation.other_participant?.name?.charAt(0).toUpperCase() || '?'}
                        </span>
                      </div>
                    )}

                    {/* Indicateur en ligne (placeholder) */}
                    <div className={`absolute -bottom-0 -right-0 ${isMobile ? 'w-3 h-3' : 'w-4 h-4'} bg-green-500 border-2 border-white dark:border-gray-800 rounded-full`}></div>
                  </div>

                  {/* Contenu */}
                  <div className="flex-1 min-w-0">
                    <div className="flex items-center justify-between mb-1">
                      <h4 className={`font-semibold truncate ${isMobile ? 'text-sm' : 'text-base'} ${
                        isDarkMode ? 'text-white' : 'text-gray-900'
                      } ${currentConversation?.id === conversation.id ? 'text-purple-300' : ''}`}>
                        {conversation.other_participant?.name || 'Utilisateur'}
                      </h4>

                      <div className="flex items-center space-x-2 flex-shrink-0">
                        <span className={`${isMobile ? 'text-xs' : 'text-xs'} ${
                          isDarkMode ? 'text-gray-400' : 'text-gray-500'
                        }`}>
                          {formatLastMessageTime(conversation.last_message_at)}
                        </span>

                        {(conversation.unread_count || 0) > 0 && (
                          <span className={`inline-flex items-center justify-center px-2 py-1 ${isMobile ? 'text-xs' : 'text-xs'} font-bold leading-none text-white bg-red-500 rounded-full min-w-[20px]`}>
                            {conversation.unread_count! > 99 ? '99+' : conversation.unread_count}
                          </span>
                        )}
                      </div>
                    </div>

                    <div className="flex items-center justify-between">
                      <p className={`${isMobile ? 'text-xs' : 'text-sm'} truncate mr-2 ${
                        isDarkMode ? 'text-gray-300' : 'text-gray-600'
                      } ${currentConversation?.id === conversation.id ? 'text-purple-200' : ''}`}>
                        {getLastMessagePreview(conversation)}
                      </p>

                      {conversation.last_message?.edited_at && (
                        <span className={`text-xs italic ${
                          isDarkMode ? 'text-gray-500' : 'text-gray-400'
                        }`}>
                          modifi√©
                        </span>
                      )}
                    </div>
                  </div>

                  {/* Menu options (masqu√© sur mobile pour l'espace) */}
                  {!isMobile && (
                    <div
                      onClick={(e: React.MouseEvent) => {
                        e.stopPropagation();
                        // TODO: Menu options conversation
                      }}
                      className={`p-1 rounded-lg opacity-0 group-hover:opacity-100 cursor-pointer transition-opacity ${
                        isDarkMode
                          ? 'hover:bg-gray-600 text-gray-400'
                          : 'hover:bg-gray-200 text-gray-500'
                      }`}
                    >
                      <MoreVertical className="w-4 h-4" />
                    </div>
                  )}
                </div>
              </button>
            ))}
          </div>
        )}
      </div>

      {/* Footer avec statistiques (masqu√© sur mobile si pas de place) */}
      {conversations.length > 0 && !isMobile && (
        <div className={`p-4 border-t ${isDarkMode ? 'border-gray-700' : 'border-gray-200'}`}>
          <div className="flex items-center justify-center space-x-4 text-sm">
            <div className="flex items-center space-x-1">
              <MessageCircle className={`w-4 h-4 ${isDarkMode ? 'text-gray-400' : 'text-gray-500'}`} />
              <span className={isDarkMode ? 'text-gray-400' : 'text-gray-600'}>
                {conversations.length}
              </span>
            </div>
            <div className="flex items-center space-x-1">
              <Clock className={`w-4 h-4 ${isDarkMode ? 'text-gray-400' : 'text-gray-500'}`} />
              <span className={isDarkMode ? 'text-gray-400' : 'text-gray-600'}>
                Mis √† jour
              </span>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};// =============================================


--- - ---

// LISTE DES CONVERSATIONS MOBILE - frontend/src/components/chat/ConversationList.tsx
// =============================================

import React, { useState } from 'react';
import { Search, MoreVertical, RefreshCw, MessageCircle, Clock, ArrowLeft } from 'lucide-react';
import { chatService } from '../../services/chatService';
import type { Conversation, ChatStats } from '../../../../shared/types/chat';

interface ConversationListProps {
  conversations: Conversation[];
  currentConversation: Conversation | null;
  onSelectConversation: (conversation: Conversation) => void;
  isDarkMode: boolean;
  chatStats: ChatStats;
  isLoading: boolean;
  onRefresh: () => void;
  isMobile?: boolean;
}

export const ConversationList: React.FC<ConversationListProps> = ({
  conversations,
  currentConversation,
  onSelectConversation,
  isDarkMode,
  chatStats,
  isLoading,
  onRefresh,
  isMobile = false
}) => {
  const [searchQuery, setSearchQuery] = useState('');
  const [isRefreshing, setIsRefreshing] = useState(false);

  // Filtrer les conversations par recherche
  const filteredConversations = conversations.filter(conv =>
    conv.other_participant?.name?.toLowerCase().includes(searchQuery.toLowerCase()) ||
    (conv.last_message?.content && conv.last_message.content.toLowerCase().includes(searchQuery.toLowerCase()))
  );

  const handleRefresh = async () => {
    setIsRefreshing(true);
    await onRefresh();
    setTimeout(() => setIsRefreshing(false), 500);
  };

  const formatLastMessageTime = (dateString: string) => {
    const date = new Date(dateString);
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMins / 60);
    const diffDays = Math.floor(diffHours / 24);

    if (diffMins < 1) return 'maintenant';
    if (diffMins < 60) return `${diffMins}min`;
    if (diffHours < 24) return `${diffHours}h`;
    if (diffDays < 7) return `${diffDays}j`;

    return date.toLocaleDateString('fr-FR', {
      day: 'numeric',
      month: 'short'
    });
  };

  const getLastMessagePreview = (conversation: Conversation) => {
    if (!conversation.last_message) return 'Nouvelle conversation';

    const msg = conversation.last_message;
    if (msg.message_type === 'system') return msg.content || 'Message syst√®me';
    if (msg.message_type === 'image') return 'üì∑ Image';
    if (msg.message_type === 'voice') return 'üéµ Message vocal';

    const content = msg.content || '';
    return content.length > (isMobile ? 35 : 40) ? content.substring(0, isMobile ? 35 : 40) + '...' : content;
  };

  return (
    <div className={`h-full flex flex-col ${isDarkMode ? 'bg-gray-800' : 'bg-white'}`}>

      {/* Header */}
      <div className={`${isMobile ? 'p-3' : 'p-4'} border-b ${isDarkMode ? 'border-gray-700' : 'border-gray-200'}`}>
        <div className="flex items-center justify-between mb-4">
          <div>
            <h2 className={`${isMobile ? 'text-lg' : 'text-xl'} font-bold ${isDarkMode ? 'text-white' : 'text-gray-900'}`}>
              Messages
            </h2>
            <p className={`text-xs ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}>
              {conversations.length} conversation{conversations.length !== 1 ? 's' : ''}
              {chatStats.total_unread_conversations > 0 && (
                <span className="ml-2 px-2 py-0.5 bg-red-500 text-white text-xs rounded-full">
                  {chatStats.total_unread_conversations} non lue{chatStats.total_unread_conversations !== 1 ? 's' : ''}
                </span>
              )}
            </p>
          </div>

          <div
            onClick={handleRefresh}
            disabled={isLoading || isRefreshing}
            className={`p-2 rounded-lg transition-all duration-200 ${
              isDarkMode
                ? 'hover:bg-gray-700 text-gray-300'
                : 'hover:bg-gray-100 text-gray-600'
            } ${(isLoading || isRefreshing) ? 'opacity-50' : ''}`}
            title="Actualiser"
          >
            <RefreshCw className={`${isMobile ? 'w-4 h-4' : 'w-5 h-5'} ${isRefreshing ? 'animate-spin' : ''}`} />
          </div>
        </div>

        {/* Barre de recherche */}
        <div className="relative">
          <Search className={`absolute left-3 top-1/2 transform -translate-y-1/2 ${isMobile ? 'w-3.5 h-3.5' : 'w-4 h-4'} ${
            isDarkMode ? 'text-gray-400' : 'text-gray-500'
          }`} />
          <input
            type="text"
            placeholder="Rechercher une conversation..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className={`w-full ${isMobile ? 'pl-9 pr-3 py-2.5 text-sm' : 'pl-10 pr-4 py-2'} rounded-lg border transition-colors ${
              isDarkMode
                ? 'bg-gray-700 border-gray-600 text-white placeholder-gray-400 focus:border-purple-500'
                : 'bg-gray-50 border-gray-300 text-gray-900 placeholder-gray-500 focus:border-purple-500'
            } focus:outline-none focus:ring-2 focus:ring-purple-500/20`}
          />
        </div>
      </div>

      {/* Liste des conversations */}
      <div className="flex-1 overflow-y-auto">
        {isLoading ? (
          <div className="p-6 text-center">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-purple-500 mx-auto mb-4"></div>
            <p className={`text-sm ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}>
              Chargement des conversations...
            </p>
          </div>
        ) : filteredConversations.length === 0 ? (
          <div className="p-6 text-center">
            {conversations.length === 0 ? (
              // Aucune conversation
              <div className="space-y-4">
                <div className="w-16 h-16 mx-auto rounded-full bg-gradient-to-br from-purple-500/20 to-pink-500/20 flex items-center justify-center">
                  <MessageCircle className={`w-8 h-8 ${isDarkMode ? 'text-gray-500' : 'text-gray-400'}`} />
                </div>
                <div>
                  <h3 className={`text-lg font-semibold mb-2 ${isDarkMode ? 'text-white' : 'text-gray-900'}`}>
                    Aucune conversation
                  </h3>
                  <p className={`text-sm ${isDarkMode ? 'text-gray-400' : 'text-gray-600'} ${isMobile ? 'px-4' : ''}`}>
                    Les conversations se cr√©ent automatiquement quand quelqu'un accepte votre demande de miroir !
                  </p>
                </div>
              </div>
            ) : (
              // Pas de r√©sultats de recherche
              <div className="space-y-4">
                <Search className={`w-12 h-12 mx-auto ${isDarkMode ? 'text-gray-500' : 'text-gray-400'}`} />
                <div>
                  <h3 className={`text-lg font-semibold mb-2 ${isDarkMode ? 'text-white' : 'text-gray-900'}`}>
                    Aucun r√©sultat
                  </h3>
                  <p className={`text-sm ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}>
                    Aucune conversation ne correspond √† "{searchQuery}"
                  </p>
                </div>
              </div>
            )}
          </div>
        ) : (
          <div className={isMobile ? 'space-y-0' : 'space-y-1'}>
            {filteredConversations.map((conversation) => (
              <div
                key={conversation.id}
                onClick={() => onSelectConversation(conversation)}
                className={`w-full text-left ${isMobile ? 'p-3' : 'p-4'} transition-all duration-200 border-l-4 ${
                  isMobile ? 'active:scale-[0.98]' : 'hover:scale-[1.02]'
                } ${
                  currentConversation?.id === conversation.id
                    ? `border-l-purple-500 ${
                        isDarkMode
                          ? 'bg-purple-900/30 shadow-lg shadow-purple-900/20'
                          : 'bg-purple-50 shadow-lg shadow-purple-500/10'
                      }`
                    : `border-l-transparent ${
                        isDarkMode
                          ? 'hover:bg-gray-700/50 active:bg-gray-700/70'
                          : 'hover:bg-gray-50 active:bg-gray-100'
                      }`
                }`}
              >
                <div className="flex items-center space-x-3">
                  {/* Avatar */}
                  <div className="relative flex-shrink-0">
                    {conversation.other_participant?.avatar_url ? (
                      <img
                        src={conversation.other_participant.avatar_url}
                        alt={conversation.other_participant.name}
                        className={`${isMobile ? 'w-10 h-10' : 'w-12 h-12'} rounded-full object-cover ring-2 ring-white/10`}
                      />
                    ) : (
                      <div className={`${isMobile ? 'w-10 h-10' : 'w-12 h-12'} rounded-full bg-gradient-to-br from-purple-500 to-pink-500 flex items-center justify-center ring-2 ring-white/10`}>
                        <span className="text-white font-bold text-lg">
                          {conversation.other_participant?.name?.charAt(0).toUpperCase() || '?'}
                        </span>
                      </div>
                    )}

                    {/* Indicateur en ligne (placeholder) */}
                    <div className={`absolute -bottom-0 -right-0 ${isMobile ? 'w-3 h-3' : 'w-4 h-4'} bg-green-500 border-2 border-white dark:border-gray-800 rounded-full`}></div>
                  </div>

                  {/* Contenu */}
                  <div className="flex-1 min-w-0">
                    <div className="flex items-center justify-between mb-1">
                      <h4 className={`font-semibold truncate ${isMobile ? 'text-sm' : 'text-base'} ${
                        isDarkMode ? 'text-white' : 'text-gray-900'
                      } ${currentConversation?.id === conversation.id ? 'text-purple-300' : ''}`}>
                        {conversation.other_participant?.name || 'Utilisateur'}
                      </h4>

                      <div className="flex items-center space-x-2 flex-shrink-0">
                        <span className={`${isMobile ? 'text-xs' : 'text-xs'} ${
                          isDarkMode ? 'text-gray-400' : 'text-gray-500'
                        }`}>
                          {formatLastMessageTime(conversation.last_message_at)}
                        </span>

                        {(conversation.unread_count || 0) > 0 && (
                          <span className={`inline-flex items-center justify-center px-2 py-1 ${isMobile ? 'text-xs' : 'text-xs'} font-bold leading-none text-white bg-red-500 rounded-full min-w-[20px]`}>
                            {conversation.unread_count! > 99 ? '99+' : conversation.unread_count}
                          </span>
                        )}
                      </div>
                    </div>

                    <div className="flex items-center justify-between">
                      <p className={`${isMobile ? 'text-xs' : 'text-sm'} truncate mr-2 ${
                        isDarkMode ? 'text-gray-300' : 'text-gray-600'
                      } ${currentConversation?.id === conversation.id ? 'text-purple-200' : ''}`}>
                        {getLastMessagePreview(conversation)}
                      </p>

                      {conversation.last_message?.edited_at && (
                        <span className={`text-xs italic ${
                          isDarkMode ? 'text-gray-500' : 'text-gray-400'
                        }`}>
                          modifi√©
                        </span>
                      )}
                    </div>
                  </div>

                  {/* Menu options (masqu√© sur mobile pour l'espace) */}
                  {!isMobile && (
                    <div
                      onClick={(e: React.MouseEvent) => {
                        e.stopPropagation();
                        // TODO: Menu options conversation
                      }}
                      className={`p-1 rounded-lg opacity-0 group-hover:opacity-100 cursor-pointer transition-opacity ${
                        isDarkMode
                          ? 'hover:bg-gray-600 text-gray-400'
                          : 'hover:bg-gray-200 text-gray-500'
                      }`}
                    >
                      <MoreVertical className="w-4 h-4" />
                    </div>
                  )}
                </div>
              </div>
            ))}
          </div>
        )}
      </div>

      {/* Footer avec statistiques (masqu√© sur mobile si pas de place) */}
      {conversations.length > 0 && !isMobile && (
        <div className={`p-4 border-t ${isDarkMode ? 'border-gray-700' : 'border-gray-200'}`}>
          <div className="flex items-center justify-center space-x-4 text-sm">
            <div className="flex items-center space-x-1">
              <MessageCircle className={`w-4 h-4 ${isDarkMode ? 'text-gray-400' : 'text-gray-500'}`} />
              <span className={isDarkMode ? 'text-gray-400' : 'text-gray-600'}>
                {conversations.length}
              </span>
            </div>
            <div className="flex items-center space-x-1">
              <Clock className={`w-4 h-4 ${isDarkMode ? 'text-gray-400' : 'text-gray-500'}`} />
              <span className={isDarkMode ? 'text-gray-400' : 'text-gray-600'}>
                Mis √† jour
              </span>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};// =============================================


--- - ---

// INDEX EXPORT - frontend/src/components/chat/index.ts
// =============================================

// Composants principaux
export { ChatPage } from './ChatPage';
export { ChatTest } from './ChatTest';
export { ChatWindow } from './ChatWindow';
export { ConversationList } from './ConversationList';
export { MessageList } from './MessageList';
export { MessageBubble } from './MessageBubble';
export { MessageInput } from './MessageInput';

// Hook principal
export { useChat } from '../../hooks/useChat';

// Service (ton service existant - parfait comme il est !)
export { chatService } from '../../services/chatService';

// Types r√©export√©s pour faciliter l'import
export type {
  Conversation,
  Message,
  ChatStats,
  SendMessageParams,
  MessageReaction,
  ChatPageProps,
  ConversationListProps,
  ChatWindowProps,
  MessageListProps,
  MessageBubbleProps,
  MessageInputProps
} from '../../../../shared/types/chat';// =============================================


--- - ---

// BULLE DE MESSAGE - frontend/src/components/chat/MessageBubble.tsx
// =============================================

import React, { useState } from 'react';
import { MoreVertical, Reply, Copy, Trash2, Edit3, Clock, Check } from 'lucide-react';
import { chatService } from '../../services/chatService';
import type { Message } from '../../../../shared/types/chat';

interface MessageBubbleProps {
  message: Message;
  onReactToMessage: (messageId: string, emoji: string) => void;
  onDeleteMessage: (messageId: string) => void;
  isDarkMode: boolean;
  isGrouped?: boolean; // Si le message fait partie d'un groupe (m√™me sender cons√©cutif)
  isMobile?: boolean; // Affichage mobile
}

export const MessageBubble: React.FC<MessageBubbleProps> = ({
  message,
  onReactToMessage,
  onDeleteMessage,
  isDarkMode,
  isGrouped = false,
  isMobile = false
}) => {
  const [showActions, setShowActions] = useState(false);
  const [showReactionPicker, setShowReactionPicker] = useState(false);
  const [isHovered, setIsHovered] = useState(false);

  const isOwn = message.is_own_message;
  const isSystem = message.message_type === 'system';
  const isExpired = message.is_expired || chatService.isMessageExpired(message);

  const formatTime = (dateString: string) => {
    return new Date(dateString).toLocaleTimeString('fr-FR', {
      hour: '2-digit',
      minute: '2-digit'
    });
  };

  const handleReaction = (emoji: string) => {
    onReactToMessage(message.id, emoji);
    setShowReactionPicker(false);
  };

  const handleCopyMessage = () => {
    if (message.content) {
      navigator.clipboard.writeText(message.content);
      // TODO: Afficher une notification "Copi√©"
    }
    setShowActions(false);
  };

  const handleDeleteMessage = () => {
    onDeleteMessage(message.id);
    setShowActions(false);
  };

  const reactions = chatService.getMessageReactions(message);
  const commonEmojis = ['‚ù§Ô∏è', 'üòÇ', 'üëç', 'üòÆ', 'üò¢', 'üò°', 'üî•', 'üíØ'];

  // Message syst√®me
  if (isSystem) {
    return (
      <div className="flex justify-center my-4">
        <div className={`px-4 py-2 rounded-full text-sm max-w-md text-center ${
          isDarkMode
            ? 'bg-gray-800 text-gray-300 border border-gray-700'
            : 'bg-gray-100 text-gray-600 border border-gray-200'
        }`}>
          {message.content}
        </div>
      </div>
    );
  }

  return (
    <div
      className={`flex ${isOwn ? 'justify-end' : 'justify-start'} ${isGrouped ? 'mt-1' : 'mt-4'}`}
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
    >
      <div className={`${isMobile ? 'max-w-[85%]' : 'max-w-xs lg:max-w-md'} relative group ${isOwn ? 'order-2' : 'order-1'}`}>

        {/* Avatar (seulement si pas group√© et pas own) */}
        {!isGrouped && !isOwn && (
          <div className="flex items-end mb-2">
            {message.sender?.avatar_url ? (
              <img
                src={message.sender.avatar_url}
                alt={message.sender.name}
                className="w-6 h-6 rounded-full object-cover mr-2"
              />
            ) : (
              <div className="w-6 h-6 rounded-full bg-gradient-to-br from-purple-500 to-pink-500 flex items-center justify-center mr-2">
                <span className="text-white text-xs font-bold">
                  {message.sender?.name?.charAt(0).toUpperCase() || '?'}
                </span>
              </div>
            )}
            <span className={`text-xs ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}>
              {message.sender?.name}
            </span>
          </div>
        )}

        <div className="flex items-end space-x-2 group">
          {!isOwn && isGrouped && <div className="w-6" />} {/* Espacement pour alignement */}

          {/* Bulle de message */}
          <div
            className={`
              relative px-4 py-2 rounded-2xl max-w-full break-words
              ${isOwn
                ? 'bg-gradient-to-r from-purple-600 to-pink-600 text-white rounded-br-md'
                : isDarkMode
                  ? 'bg-gray-700 text-white rounded-bl-md'
                  : 'bg-white text-gray-900 shadow-sm border border-gray-200 rounded-bl-md'
              }
              ${isExpired ? 'opacity-50' : ''}
              ${isGrouped ? (isOwn ? 'rounded-tr-2xl' : 'rounded-tl-2xl') : ''}
            `}
          >
            {/* Contenu du message */}
            <div className="space-y-1">
              {/* Message de r√©ponse (si applicable) */}
              {message.reply_to && (
                <div className={`p-2 rounded-lg text-xs border-l-2 ${
                  isOwn
                    ? 'bg-white/10 border-white/30 text-purple-100'
                    : isDarkMode
                      ? 'bg-gray-600 border-gray-500 text-gray-300'
                      : 'bg-gray-50 border-gray-300 text-gray-600'
                }`}>
                  <div className="font-medium mb-1">
                    En r√©ponse √† {message.reply_to.sender?.name}
                  </div>
                  <div className="truncate">
                    {message.reply_to.content?.substring(0, 50)}...
                  </div>
                </div>
              )}

              {/* Contenu principal */}
              {message.content && (
                <div className="text-sm leading-relaxed whitespace-pre-wrap">
                  {message.content}
                </div>
              )}

              {/* Media (image/voice) */}
              {message.message_type === 'image' && message.media_url && (
                <div className="mt-2">
                  <img
                    src={message.media_url}
                    alt="Image partag√©e"
                    className="max-w-full h-auto rounded-lg"
                    loading="lazy"
                  />
                </div>
              )}

              {message.message_type === 'voice' && message.media_url && (
                <div className="mt-2 flex items-center space-x-2">
                  <button className="p-2 rounded-full bg-white/20 hover:bg-white/30 transition-colors">
                    <div className="w-4 h-4 triangle-right"></div>
                  </button>
                  <div className="flex-1 h-2 bg-white/20 rounded-full">
                    <div className="h-full w-1/3 bg-white rounded-full"></div>
                  </div>
                  <span className="text-xs opacity-75">
                    {message.media_metadata?.duration || '0:00'}
                  </span>
                </div>
              )}
            </div>

            {/* M√©tadonn√©es du message */}
            <div className={`flex items-center justify-between mt-2 text-xs ${
              isOwn ? 'text-purple-100' : isDarkMode ? 'text-gray-400' : 'text-gray-500'
            }`}>
              <div className="flex items-center space-x-2">
                <span>{formatTime(message.created_at)}</span>
                {message.edited_at && (
                  <span className="italic">modifi√©</span>
                )}
                {isExpired && (
                  <span className="flex items-center space-x-1">
                    <Clock className="w-3 h-3" />
                    <span>expir√©</span>
                  </span>
                )}
              </div>

              {isOwn && !isSystem && (
                <div className="flex items-center space-x-1">
                  <Check className="w-3 h-3" />
                  {/* <CheckCheck className="w-3 h-3" /> pour "lu" */}
                </div>
              )}
            </div>
          </div>

          {/* Actions du message (visibles au hover) */}
          {!isSystem && (isHovered || showActions) && (
            <div className={`
              flex items-center space-x-1 opacity-0 group-hover:opacity-100 transition-opacity
              ${isOwn ? 'order-1 mr-2' : 'order-3 ml-2'}
            `}>
              {/* R√©action rapide */}
              <button
                onClick={() => setShowReactionPicker(!showReactionPicker)}
                className={`p-1 rounded-full transition-colors ${
                  isDarkMode
                    ? 'hover:bg-gray-700 text-gray-400'
                    : 'hover:bg-gray-100 text-gray-600'
                }`}
                title="R√©agir"
              >
                <span className="text-sm">üòä</span>
              </button>

              {/* Menu actions */}
              <button
                onClick={() => setShowActions(!showActions)}
                className={`p-1 rounded-full transition-colors ${
                  isDarkMode
                    ? 'hover:bg-gray-700 text-gray-400'
                    : 'hover:bg-gray-100 text-gray-600'
                }`}
              >
                <MoreVertical className="w-4 h-4" />
              </button>
            </div>
          )}
        </div>

        {/* R√©actions existantes */}
        {reactions.length > 0 && (
          <div className={`flex flex-wrap gap-1 mt-1 ${isOwn ? 'justify-end' : 'justify-start'} ${!isOwn && isGrouped ? 'ml-8' : ''}`}>
            {reactions.map(({ emoji, count }) => (
              <button
                key={emoji}
                onClick={() => handleReaction(emoji)}
                className={`
                  px-2 py-1 rounded-full text-xs flex items-center space-x-1 transition-colors
                  ${isDarkMode
                    ? 'bg-gray-700 hover:bg-gray-600 text-white'
                    : 'bg-gray-100 hover:bg-gray-200 text-gray-700'
                  }
                `}
              >
                <span>{emoji}</span>
                <span>{count}</span>
              </button>
            ))}
          </div>
        )}

        {/* Picker de r√©actions */}
        {showReactionPicker && (
          <div className={`
            absolute ${isOwn ? 'right-0' : 'left-0'} bottom-full mb-2 p-2 rounded-lg shadow-lg border z-10
            ${isDarkMode ? 'bg-gray-800 border-gray-600' : 'bg-white border-gray-200'}
          `}>
            <div className="flex space-x-1">
              {commonEmojis.map(emoji => (
                <button
                  key={emoji}
                  onClick={() => handleReaction(emoji)}
                  className="text-lg hover:scale-125 transition-transform p-1 rounded"
                >
                  {emoji}
                </button>
              ))}
            </div>
          </div>
        )}

        {/* Menu d'actions */}
        {showActions && (
          <div className={`
            absolute ${isOwn ? 'right-0' : 'left-0'} bottom-full mb-2 py-1 rounded-lg shadow-lg border z-10
            ${isDarkMode ? 'bg-gray-800 border-gray-600' : 'bg-white border-gray-200'}
          `}>
            <button
              onClick={() => {/* TODO: R√©pondre */}}
              className={`flex items-center space-x-2 w-full px-3 py-2 text-sm hover:bg-gray-100 dark:hover:bg-gray-700 ${
                isDarkMode ? 'text-white' : 'text-gray-700'
              }`}
            >
              <Reply className="w-4 h-4" />
              <span>R√©pondre</span>
            </button>

            <button
              onClick={handleCopyMessage}
              className={`flex items-center space-x-2 w-full px-3 py-2 text-sm hover:bg-gray-100 dark:hover:bg-gray-700 ${
                isDarkMode ? 'text-white' : 'text-gray-700'
              }`}
            >
              <Copy className="w-4 h-4" />
              <span>Copier</span>
            </button>

            {isOwn && (
              <>
                <button
                  onClick={() => {/* TODO: √âditer */}}
                  className={`flex items-center space-x-2 w-full px-3 py-2 text-sm hover:bg-gray-100 dark:hover:bg-gray-700 ${
                    isDarkMode ? 'text-white' : 'text-gray-700'
                  }`}
                >
                  <Edit3 className="w-4 h-4" />
                  <span>Modifier</span>
                </button>

                <button
                  onClick={handleDeleteMessage}
                  className="flex items-center space-x-2 w-full px-3 py-2 text-sm hover:bg-red-50 dark:hover:bg-red-900/20 text-red-600 dark:text-red-400"
                >
                  <Trash2 className="w-4 h-4" />
                  <span>Supprimer</span>
                </button>
              </>
            )}
          </div>
        )}
      </div>
    </div>
  );
};// =============================================


--- - ---

// BULLE DE MESSAGE - frontend/src/components/chat/MessageBubble.tsx
// =============================================

import React, { useState } from 'react';
import { MoreVertical, Reply, Copy, Trash2, Edit3, Clock, Check } from 'lucide-react';
import { chatService } from '../../services/chatService';
import type { Message } from '../../../../shared/types/chat';

interface MessageBubbleProps {
  message: Message;
  onReactToMessage: (messageId: string, emoji: string) => void;
  onDeleteMessage: (messageId: string) => void;
  isDarkMode: boolean;
  isGrouped?: boolean; // Si le message fait partie d'un groupe (m√™me sender cons√©cutif)
}

export const MessageBubble: React.FC<MessageBubbleProps> = ({
  message,
  onReactToMessage,
  onDeleteMessage,
  isDarkMode,
  isGrouped = false
}) => {
  const [showActions, setShowActions] = useState(false);
  const [showReactionPicker, setShowReactionPicker] = useState(false);
  const [isHovered, setIsHovered] = useState(false);

  const isOwn = message.is_own_message;
  const isSystem = message.message_type === 'system';
  const isExpired = message.is_expired || chatService.isMessageExpired(message);

  const formatTime = (dateString: string) => {
    return new Date(dateString).toLocaleTimeString('fr-FR', {
      hour: '2-digit',
      minute: '2-digit'
    });
  };

  const handleReaction = (emoji: string) => {
    onReactToMessage(message.id, emoji);
    setShowReactionPicker(false);
  };

  const handleCopyMessage = () => {
    if (message.content) {
      navigator.clipboard.writeText(message.content);
      // TODO: Afficher une notification "Copi√©"
    }
    setShowActions(false);
  };

  const handleDeleteMessage = () => {
    onDeleteMessage(message.id);
    setShowActions(false);
  };

  const reactions = chatService.getMessageReactions(message);
  const commonEmojis = ['‚ù§Ô∏è', 'üòÇ', 'üëç', 'üòÆ', 'üò¢', 'üò°', 'üî•', 'üíØ'];

  // Message syst√®me
  if (isSystem) {
    return (
      <div className="flex justify-center my-4">
        <div className={`px-4 py-2 rounded-full text-sm max-w-md text-center ${
          isDarkMode
            ? 'bg-gray-800 text-gray-300 border border-gray-700'
            : 'bg-gray-100 text-gray-600 border border-gray-200'
        }`}>
          {message.content}
        </div>
      </div>
    );
  }

  return (
    <div
      className={`flex ${isOwn ? 'justify-end' : 'justify-start'} ${isGrouped ? 'mt-1' : 'mt-4'}`}
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
    >
      <div className={`max-w-xs lg:max-w-md relative group ${isOwn ? 'order-2' : 'order-1'}`}>

        {/* Avatar (seulement si pas group√© et pas own) */}
        {!isGrouped && !isOwn && (
          <div className="flex items-end mb-2">
            {message.sender?.avatar_url ? (
              <img
                src={message.sender.avatar_url}
                alt={message.sender.name}
                className="w-6 h-6 rounded-full object-cover mr-2"
              />
            ) : (
              <div className="w-6 h-6 rounded-full bg-gradient-to-br from-purple-500 to-pink-500 flex items-center justify-center mr-2">
                <span className="text-white text-xs font-bold">
                  {message.sender?.name?.charAt(0).toUpperCase() || '?'}
                </span>
              </div>
            )}
            <span className={`text-xs ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}>
              {message.sender?.name}
            </span>
          </div>
        )}

        <div className="flex items-end space-x-2 group">
          {!isOwn && isGrouped && <div className="w-6" />} {/* Espacement pour alignement */}

          {/* Bulle de message */}
          <div
            className={`
              relative px-4 py-2 rounded-2xl max-w-full break-words
              ${isOwn
                ? 'bg-gradient-to-r from-purple-600 to-pink-600 text-white rounded-br-md'
                : isDarkMode
                  ? 'bg-gray-700 text-white rounded-bl-md'
                  : 'bg-white text-gray-900 shadow-sm border border-gray-200 rounded-bl-md'
              }
              ${isExpired ? 'opacity-50' : ''}
              ${isGrouped ? (isOwn ? 'rounded-tr-2xl' : 'rounded-tl-2xl') : ''}
            `}
          >
            {/* Contenu du message */}
            <div className="space-y-1">
              {/* Message de r√©ponse (si applicable) */}
              {message.reply_to && (
                <div className={`p-2 rounded-lg text-xs border-l-2 ${
                  isOwn
                    ? 'bg-white/10 border-white/30 text-purple-100'
                    : isDarkMode
                      ? 'bg-gray-600 border-gray-500 text-gray-300'
                      : 'bg-gray-50 border-gray-300 text-gray-600'
                }`}>
                  <div className="font-medium mb-1">
                    En r√©ponse √† {message.reply_to.sender?.name}
                  </div>
                  <div className="truncate">
                    {message.reply_to.content?.substring(0, 50)}...
                  </div>
                </div>
              )}

              {/* Contenu principal */}
              {message.content && (
                <div className="text-sm leading-relaxed whitespace-pre-wrap">
                  {message.content}
                </div>
              )}

              {/* Media (image/voice) */}
              {message.message_type === 'image' && message.media_url && (
                <div className="mt-2">
                  <img
                    src={message.media_url}
                    alt="Image partag√©e"
                    className="max-w-full h-auto rounded-lg"
                    loading="lazy"
                  />
                </div>
              )}

              {message.message_type === 'voice' && message.media_url && (
                <div className="mt-2 flex items-center space-x-2">
                  <button className="p-2 rounded-full bg-white/20 hover:bg-white/30 transition-colors">
                    <div className="w-4 h-4 triangle-right"></div>
                  </button>
                  <div className="flex-1 h-2 bg-white/20 rounded-full">
                    <div className="h-full w-1/3 bg-white rounded-full"></div>
                  </div>
                  <span className="text-xs opacity-75">
                    {message.media_metadata?.duration || '0:00'}
                  </span>
                </div>
              )}
            </div>

            {/* M√©tadonn√©es du message */}
            <div className={`flex items-center justify-between mt-2 text-xs ${
              isOwn ? 'text-purple-100' : isDarkMode ? 'text-gray-400' : 'text-gray-500'
            }`}>
              <div className="flex items-center space-x-2">
                <span>{formatTime(message.created_at)}</span>
                {message.edited_at && (
                  <span className="italic">modifi√©</span>
                )}
                {isExpired && (
                  <span className="flex items-center space-x-1">
                    <Clock className="w-3 h-3" />
                    <span>expir√©</span>
                  </span>
                )}
              </div>

              {isOwn && !isSystem && (
                <div className="flex items-center space-x-1">
                  <Check className="w-3 h-3" />
                  {/* <CheckCheck className="w-3 h-3" /> pour "lu" */}
                </div>
              )}
            </div>
          </div>

          {/* Actions du message (visibles au hover) */}
          {!isSystem && (isHovered || showActions) && (
            <div className={`
              flex items-center space-x-1 opacity-0 group-hover:opacity-100 transition-opacity
              ${isOwn ? 'order-1 mr-2' : 'order-3 ml-2'}
            `}>
              {/* R√©action rapide */}
              <button
                onClick={() => setShowReactionPicker(!showReactionPicker)}
                className={`p-1 rounded-full transition-colors ${
                  isDarkMode
                    ? 'hover:bg-gray-700 text-gray-400'
                    : 'hover:bg-gray-100 text-gray-600'
                }`}
                title="R√©agir"
              >
                <span className="text-sm">üòä</span>
              </button>

              {/* Menu actions */}
              <button
                onClick={() => setShowActions(!showActions)}
                className={`p-1 rounded-full transition-colors ${
                  isDarkMode
                    ? 'hover:bg-gray-700 text-gray-400'
                    : 'hover:bg-gray-100 text-gray-600'
                }`}
              >
                <MoreVertical className="w-4 h-4" />
              </button>
            </div>
          )}
        </div>

        {/* R√©actions existantes */}
        {reactions.length > 0 && (
          <div className={`flex flex-wrap gap-1 mt-1 ${isOwn ? 'justify-end' : 'justify-start'} ${!isOwn && isGrouped ? 'ml-8' : ''}`}>
            {reactions.map(({ emoji, count }) => (
              <button
                key={emoji}
                onClick={() => handleReaction(emoji)}
                className={`
                  px-2 py-1 rounded-full text-xs flex items-center space-x-1 transition-colors
                  ${isDarkMode
                    ? 'bg-gray-700 hover:bg-gray-600 text-white'
                    : 'bg-gray-100 hover:bg-gray-200 text-gray-700'
                  }
                `}
              >
                <span>{emoji}</span>
                <span>{count}</span>
              </button>
            ))}
          </div>
        )}

        {/* Picker de r√©actions */}
        {showReactionPicker && (
          <div className={`
            absolute ${isOwn ? 'right-0' : 'left-0'} bottom-full mb-2 p-2 rounded-lg shadow-lg border z-10
            ${isDarkMode ? 'bg-gray-800 border-gray-600' : 'bg-white border-gray-200'}
          `}>
            <div className="flex space-x-1">
              {commonEmojis.map(emoji => (
                <button
                  key={emoji}
                  onClick={() => handleReaction(emoji)}
                  className="text-lg hover:scale-125 transition-transform p-1 rounded"
                >
                  {emoji}
                </button>
              ))}
            </div>
          </div>
        )}

        {/* Menu d'actions */}
        {showActions && (
          <div className={`
            absolute ${isOwn ? 'right-0' : 'left-0'} bottom-full mb-2 py-1 rounded-lg shadow-lg border z-10
            ${isDarkMode ? 'bg-gray-800 border-gray-600' : 'bg-white border-gray-200'}
          `}>
            <button
              onClick={() => {/* TODO: R√©pondre */}}
              className={`flex items-center space-x-2 w-full px-3 py-2 text-sm hover:bg-gray-100 dark:hover:bg-gray-700 ${
                isDarkMode ? 'text-white' : 'text-gray-700'
              }`}
            >
              <Reply className="w-4 h-4" />
              <span>R√©pondre</span>
            </button>

            <button
              onClick={handleCopyMessage}
              className={`flex items-center space-x-2 w-full px-3 py-2 text-sm hover:bg-gray-100 dark:hover:bg-gray-700 ${
                isDarkMode ? 'text-white' : 'text-gray-700'
              }`}
            >
              <Copy className="w-4 h-4" />
              <span>Copier</span>
            </button>

            {isOwn && (
              <>
                <button
                  onClick={() => {/* TODO: √âditer */}}
                  className={`flex items-center space-x-2 w-full px-3 py-2 text-sm hover:bg-gray-100 dark:hover:bg-gray-700 ${
                    isDarkMode ? 'text-white' : 'text-gray-700'
                  }`}
                >
                  <Edit3 className="w-4 h-4" />
                  <span>Modifier</span>
                </button>

                <button
                  onClick={handleDeleteMessage}
                  className="flex items-center space-x-2 w-full px-3 py-2 text-sm hover:bg-red-50 dark:hover:bg-red-900/20 text-red-600 dark:text-red-400"
                >
                  <Trash2 className="w-4 h-4" />
                  <span>Supprimer</span>
                </button>
              </>
            )}
          </div>
        )}
      </div>
    </div>
  );
};// =============================================


--- - ---

// SAISIE DE MESSAGE - frontend/src/components/chat/MessageInput.tsx
// =============================================

import React, { useState, useRef, useEffect } from 'react';
import { Send, Paperclip, Smile, X, Reply } from 'lucide-react';
import type { MessageInputProps } from '../../../../shared/types/chat';

interface MessageInputProps {
  onSendMessage: (content: string, replyToId?: string) => void;
  isDarkMode: boolean;
  disabled?: boolean;
  placeholder?: string;
  replyToMessage?: {
    id: string;
    content: string;
    senderName: string;
  } | null;
  onCancelReply?: () => void;
  isMobile?: boolean;
}

export const MessageInput: React.FC<MessageInputProps> = ({
  onSendMessage,
  isDarkMode,
  disabled = false,
  placeholder = "Tapez votre message...",
  replyToMessage,
  onCancelReply,
  isMobile = false
}) => {
  const [message, setMessage] = useState('');
  const [isSending, setIsSending] = useState(false);
  const [showEmojiPicker, setShowEmojiPicker] = useState(false);
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Emojis populaires
  const popularEmojis = [
    'üòÄ', 'üòÇ', 'üòç', 'ü•∞', 'üòé', 'üòÖ', 'ü§î', 'üòí',
    'üò≠', 'üò±', 'üò°', 'ü§ó', 'üëç', 'üëé', '‚ù§Ô∏è', 'üî•',
    'üíØ', 'üëè', 'üéâ', 'üí™', 'ü§ù', 'üôè', '‚ú®', '‚≠ê'
  ];

  // Auto-resize du textarea
  useEffect(() => {
    if (textareaRef.current) {
      textareaRef.current.style.height = 'auto';
      textareaRef.current.style.height = Math.min(textareaRef.current.scrollHeight, 120) + 'px';
    }
  }, [message]);

  // Focus automatique
  useEffect(() => {
    if (!disabled && textareaRef.current) {
      textareaRef.current.focus();
    }
  }, [disabled]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!message.trim() || isSending || disabled) return;

    try {
      setIsSending(true);
      await onSendMessage(message.trim(), replyToMessage?.id);
      setMessage('');
      if (onCancelReply) onCancelReply();
    } catch (error) {
      console.error('‚ùå Erreur envoi message:', error);
      // TODO: Afficher une notification d'erreur
    } finally {
      setIsSending(false);
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    // Envoyer avec Entr√©e (sauf si Shift+Entr√©e)
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSubmit(e);
    }

    // Fermer l'emoji picker avec Escape
    if (e.key === 'Escape' && showEmojiPicker) {
      setShowEmojiPicker(false);
    }
  };

  const handleEmojiClick = (emoji: string) => {
    const textarea = textareaRef.current;
    if (!textarea) return;

    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const newMessage = message.slice(0, start) + emoji + message.slice(end);

    setMessage(newMessage);
    setShowEmojiPicker(false);

    // Remettre le focus et positionner le curseur
    setTimeout(() => {
      textarea.focus();
      textarea.setSelectionRange(start + emoji.length, start + emoji.length);
    }, 0);
  };

  const handleFileSelect = () => {
    fileInputRef.current?.click();
  };

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    // TODO: G√©rer l'upload de fichiers
    console.log('üìé Fichier s√©lectionn√©:', file.name);

    // Reset l'input
    e.target.value = '';
  };

  // Gestion du typing indicator (mobile)
  useEffect(() => {
    let timeoutId: NodeJS.Timeout;

    if (message.trim() && textareaRef.current) {
      // TODO: Envoyer typing indicator
      timeoutId = setTimeout(() => {
        // TODO: Arr√™ter typing indicator
      }, 1000);
    }

    return () => {
      if (timeoutId) clearTimeout(timeoutId);
    };
  }, [message]);

  const canSend = message.trim().length > 0 && !isSending && !disabled;

  return (
    <div className={`relative ${isDarkMode ? 'bg-gray-800' : 'bg-white'}`}>

      {/* R√©ponse √† un message */}
      {replyToMessage && (
        <div className={`px-4 py-3 border-b ${
          isDarkMode ? 'border-gray-700 bg-gray-700/50' : 'border-gray-200 bg-gray-50'
        }`}>
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-2">
              <Reply className={`w-4 h-4 ${isDarkMode ? 'text-purple-400' : 'text-purple-600'}`} />
              <span className={`text-sm font-medium ${isDarkMode ? 'text-purple-400' : 'text-purple-600'}`}>
                R√©pondre √† {replyToMessage.senderName}
              </span>
            </div>
            {onCancelReply && (
              <button
                onClick={onCancelReply}
                className={`p-1 rounded hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors ${
                  isDarkMode ? 'text-gray-400' : 'text-gray-600'
                }`}
              >
                <X className="w-4 h-4" />
              </button>
            )}
          </div>
          <p className={`text-sm mt-1 truncate ${isDarkMode ? 'text-gray-300' : 'text-gray-600'}`}>
            {replyToMessage.content}
          </p>
        </div>
      )}

      {/* Zone de saisie principale */}
      <form onSubmit={handleSubmit} className={isMobile ? "p-3" : "p-4"}>
        <div className={`
          flex items-end space-x-3 ${isMobile ? 'p-2' : 'p-3'} rounded-2xl border transition-colors
          ${isDarkMode
            ? 'border-gray-600 bg-gray-700/50 focus-within:border-purple-500'
            : 'border-gray-300 bg-gray-50 focus-within:border-purple-500'
          }
          ${disabled ? 'opacity-50 cursor-not-allowed' : ''}
        `}>

          {/* Bouton fichier */}
          <button
            type="button"
            onClick={handleFileSelect}
            disabled={disabled}
            className={`${isMobile ? 'p-1.5' : 'p-2'} rounded-full transition-colors flex-shrink-0 ${
              isDarkMode
                ? 'text-gray-400 hover:text-gray-300 hover:bg-gray-600'
                : 'text-gray-500 hover:text-gray-700 hover:bg-gray-200'
            } ${disabled ? 'cursor-not-allowed' : ''}`}
            title="Joindre un fichier"
          >
            <Paperclip className={`${isMobile ? 'w-4 h-4' : 'w-5 h-5'}`} />
          </button>

          {/* Zone de texte */}
          <div className="flex-1 relative">
            <textarea
              ref={textareaRef}
              value={message}
              onChange={(e) => setMessage(e.target.value)}
              onKeyDown={handleKeyDown}
              placeholder={disabled ? 'Chargement...' : placeholder}
              disabled={disabled}
              rows={1}
              className={`
                w-full resize-none border-0 bg-transparent outline-none
                ${isDarkMode ? 'text-white placeholder-gray-400' : 'text-gray-900 placeholder-gray-500'}
                ${disabled ? 'cursor-not-allowed' : ''}
              `}
              style={{
                minHeight: '24px',
                maxHeight: '120px',
                lineHeight: '24px'
              }}
            />

            {/* Compteur de caract√®res */}
            {message.length > 3800 && (
              <div className={`absolute -top-6 right-0 text-xs ${
                message.length > 4000
                  ? 'text-red-500'
                  : message.length > 3900
                    ? 'text-yellow-500'
                    : isDarkMode ? 'text-gray-400' : 'text-gray-600'
              }`}>
                {message.length}/4000
              </div>
            )}
          </div>

          {/* Bouton emoji */}
          <div className="relative flex-shrink-0">
            <button
              type="button"
              onClick={() => setShowEmojiPicker(!showEmojiPicker)}
              disabled={disabled}
              className={`${isMobile ? 'p-1.5' : 'p-2'} rounded-full transition-colors ${
                isDarkMode
                  ? 'text-gray-400 hover:text-gray-300 hover:bg-gray-600'
                  : 'text-gray-500 hover:text-gray-700 hover:bg-gray-200'
              } ${disabled ? 'cursor-not-allowed' : ''}`}
              title="Ajouter un emoji"
            >
              <Smile className={`${isMobile ? 'w-4 h-4' : 'w-5 h-5'}`} />
            </button>

            {/* Picker d'emojis */}
            {showEmojiPicker && (
              <>
                {/* Overlay pour fermer */}
                <div
                  className="fixed inset-0 z-10"
                  onClick={() => setShowEmojiPicker(false)}
                />

                {/* Popup emojis */}
                <div className={`
                  absolute bottom-full right-0 mb-2 p-3 rounded-lg shadow-lg border z-20
                  ${isDarkMode ? 'bg-gray-800 border-gray-600' : 'bg-white border-gray-200'}
                `}>
                  <div className="grid grid-cols-8 gap-1 max-w-xs">
                    {popularEmojis.map((emoji, index) => (
                      <button
                        key={index}
                        type="button"
                        onClick={() => handleEmojiClick(emoji)}
                        className="text-lg p-1 rounded hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"
                      >
                        {emoji}
                      </button>
                    ))}
                  </div>
                </div>
              </>
            )}
          </div>

          {/* Bouton d'envoi */}
          <button
            type="submit"
            disabled={!canSend}
            className={`
              ${isMobile ? 'p-1.5' : 'p-2'} rounded-full transition-all duration-200 flex-shrink-0
              ${canSend
                ? 'bg-gradient-to-r from-purple-600 to-pink-600 text-white hover:shadow-lg hover:scale-105'
                : isDarkMode
                  ? 'bg-gray-600 text-gray-400 cursor-not-allowed'
                  : 'bg-gray-300 text-gray-500 cursor-not-allowed'
              }
            `}
            title={canSend ? 'Envoyer le message' : 'Saisissez un message'}
          >
            {isSending ? (
              <div className={`${isMobile ? 'w-4 h-4' : 'w-5 h-5'} animate-spin rounded-full border-2 border-white border-t-transparent`} />
            ) : (
              <Send className={`${isMobile ? 'w-4 h-4' : 'w-5 h-5'}`} />
            )}
          </button>
        </div>

        {/* Input fichier cach√© */}
        <input
          ref={fileInputRef}
          type="file"
          className="hidden"
          onChange={handleFileChange}
          accept="image/*,audio/*,.pdf,.doc,.docx"
        />

        {/* Indication des raccourcis */}
        <div className={`flex justify-between items-center mt-2 text-xs ${
          isDarkMode ? 'text-gray-500' : 'text-gray-400'
        }`}>
          <span>Entr√©e pour envoyer, Shift+Entr√©e pour nouvelle ligne</span>
          {message.length > 0 && (
            <span className={message.length > 4000 ? 'text-red-500' : ''}>
              {message.length} caract√®res
            </span>
          )}
        </div>
      </form>
    </div>
  );
};// =============================================


--- - ---

// LISTE DES MESSAGES MOBILE - frontend/src/components/chat/MessageList.tsx
// =============================================

import React, { useRef, useEffect } from 'react';
import { MessageBubble } from './MessageBubble';
import { AlertCircle, MessageCircle } from 'lucide-react';
import type { Message } from '../../../../shared/types/chat';

interface MessageListProps {
  messages: Message[];
  isLoading: boolean;
  onReactToMessage: (messageId: string, emoji: string) => void;
  onDeleteMessage: (messageId: string) => void;
  isDarkMode: boolean;
  isMobile?: boolean;
}

export const MessageList: React.FC<MessageListProps> = ({
  messages,
  isLoading,
  onReactToMessage,
  onDeleteMessage,
  isDarkMode,
  isMobile = false
}) => {
  const scrollAreaRef = useRef<HTMLDivElement>(null);
  const bottomRef = useRef<HTMLDivElement>(null);

  // Auto-scroll vers le bas lors de nouveaux messages
  useEffect(() => {
    if (bottomRef.current) {
      bottomRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [messages]);

  // Grouper les messages par date
  const groupMessagesByDate = (messages: Message[]) => {
    const groups: { [key: string]: Message[] } = {};

    messages.forEach(message => {
      const date = new Date(message.created_at);
      const dateKey = date.toDateString();

      if (!groups[dateKey]) {
        groups[dateKey] = [];
      }
      groups[dateKey].push(message);
    });

    return groups;
  };

  const formatDateHeader = (dateString: string) => {
    const date = new Date(dateString);
    const today = new Date();
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);

    if (date.toDateString() === today.toDateString()) {
      return "Aujourd'hui";
    } else if (date.toDateString() === yesterday.toDateString()) {
      return "Hier";
    } else {
      return date.toLocaleDateString('fr-FR', {
        weekday: isMobile ? 'short' : 'long',
        day: 'numeric',
        month: isMobile ? 'short' : 'long'
      });
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-full">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-purple-500 mx-auto mb-4"></div>
          <p className={`text-sm ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}>
            Chargement des messages...
          </p>
        </div>
      </div>
    );
  }

  if (messages.length === 0) {
    return (
      <div className="flex items-center justify-center h-full">
        <div className={`text-center ${isMobile ? 'max-w-xs' : 'max-w-sm'} mx-auto ${isMobile ? 'p-4' : 'p-8'}`}>
          <div className={`${isMobile ? 'w-12 h-12' : 'w-16 h-16'} mx-auto mb-6 rounded-full bg-gradient-to-br from-purple-500/20 to-pink-500/20 flex items-center justify-center`}>
            <MessageCircle className={`${isMobile ? 'w-6 h-6' : 'w-8 h-8'} ${isDarkMode ? 'text-gray-500' : 'text-gray-400'}`} />
          </div>

          <h3 className={`${isMobile ? 'text-base' : 'text-lg'} font-semibold mb-3 ${isDarkMode ? 'text-white' : 'text-gray-900'}`}>
            D√©but de votre conversation
          </h3>

          <p className={`text-sm mb-6 ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}>
            Envoyez votre premier message pour commencer √† discuter !
          </p>

          <div className={`p-4 rounded-lg ${isDarkMode ? 'bg-purple-900/20 border border-purple-800/30' : 'bg-purple-50 border border-purple-200'}`}>
            <p className={`text-xs ${isDarkMode ? 'text-purple-300' : 'text-purple-700'}`}>
              üí° Cette conversation a √©t√© cr√©√©e suite √† l'acceptation d'une demande de miroir
            </p>
          </div>
        </div>
      </div>
    );
  }

  const messageGroups = groupMessagesByDate(messages);
  const groupEntries = Object.entries(messageGroups).sort(([a], [b]) =>
    new Date(a).getTime() - new Date(b).getTime()
  );

  return (
    <div
      ref={scrollAreaRef}
      className={`h-full overflow-y-auto ${isMobile ? 'p-3' : 'p-4'} space-y-4 ${isDarkMode ? 'bg-gray-900' : 'bg-gray-50'}`}
      style={{ scrollBehavior: 'smooth' }}
    >
      {groupEntries.map(([dateString, dayMessages], groupIndex) => (
        <div key={`group-${dateString}-${groupIndex}`} className="space-y-3">

          {/* S√©parateur de date */}
          <div className="flex items-center justify-center">
            <div className={`${isMobile ? 'px-3 py-1.5' : 'px-4 py-2'} rounded-full ${isMobile ? 'text-xs' : 'text-xs'} font-medium ${
              isDarkMode
                ? 'bg-gray-800 text-gray-400 border border-gray-700'
                : 'bg-white text-gray-600 border border-gray-200 shadow-sm'
            }`}>
              {formatDateHeader(dateString)}
            </div>
          </div>

          {/* Messages du jour */}
          <div className={isMobile ? 'space-y-2' : 'space-y-3'}>
            {dayMessages.map((message, index) => {
              const prevMessage = index > 0 ? dayMessages[index - 1] : null;
              const isGrouped = prevMessage &&
                prevMessage.sender_id === message.sender_id &&
                new Date(message.created_at).getTime() - new Date(prevMessage.created_at).getTime() < 5 * 60 * 1000; // 5 minutes

              return (
                <MessageBubble
                  key={message.id}
                  message={message}
                  onReactToMessage={onReactToMessage}
                  onDeleteMessage={onDeleteMessage}
                  isDarkMode={isDarkMode}
                  isGrouped={isGrouped}
                  isMobile={isMobile}
                />
              );
            })}
          </div>
        </div>
      ))}

      {/* Ancre pour auto-scroll */}
      <div ref={bottomRef} />
    </div>
  );
};// =============================================


--- - ---

// LISTE DES MESSAGES MOBILE - frontend/src/components/chat/MessageList.tsx
// =============================================

import React, { useRef, useEffect } from 'react';
import { MessageBubble } from './MessageBubble';
import { AlertCircle, MessageCircle } from 'lucide-react';
import type { Message } from '../../../../shared/types/chat';

interface MessageListProps {
  messages: Message[];
  isLoading: boolean;
  onReactToMessage: (messageId: string, emoji: string) => void;
  onDeleteMessage: (messageId: string) => void;
  isDarkMode: boolean;
  isMobile?: boolean;
}

export const MessageList: React.FC<MessageListProps> = ({
  messages,
  isLoading,
  onReactToMessage,
  onDeleteMessage,
  isDarkMode,
  isMobile = false
}) => {
  const scrollAreaRef = useRef<HTMLDivElement>(null);
  const bottomRef = useRef<HTMLDivElement>(null);

  // Auto-scroll vers le bas lors de nouveaux messages
  useEffect(() => {
    if (bottomRef.current) {
      bottomRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [messages]);

  // Grouper les messages par date
  const groupMessagesByDate = (messages: Message[]) => {
    const groups: { [key: string]: Message[] } = {};

    messages.forEach(message => {
      const date = new Date(message.created_at);
      const dateKey = date.toDateString();

      if (!groups[dateKey]) {
        groups[dateKey] = [];
      }
      groups[dateKey].push(message);
    });

    return groups;
  };

  const formatDateHeader = (dateString: string) => {
    const date = new Date(dateString);
    const today = new Date();
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);

    if (date.toDateString() === today.toDateString()) {
      return "Aujourd'hui";
    } else if (date.toDateString() === yesterday.toDateString()) {
      return "Hier";
    } else {
      return date.toLocaleDateString('fr-FR', {
        weekday: isMobile ? 'short' : 'long',
        day: 'numeric',
        month: isMobile ? 'short' : 'long'
      });
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-full">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-purple-500 mx-auto mb-4"></div>
          <p className={`text-sm ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}>
            Chargement des messages...
          </p>
        </div>
      </div>
    );
  }

  if (messages.length === 0) {
    return (
      <div className="flex items-center justify-center h-full">
        <div className={`text-center ${isMobile ? 'max-w-xs' : 'max-w-sm'} mx-auto ${isMobile ? 'p-4' : 'p-8'}`}>
          <div className={`${isMobile ? 'w-12 h-12' : 'w-16 h-16'} mx-auto mb-6 rounded-full bg-gradient-to-br from-purple-500/20 to-pink-500/20 flex items-center justify-center`}>
            <MessageCircle className={`${isMobile ? 'w-6 h-6' : 'w-8 h-8'} ${isDarkMode ? 'text-gray-500' : 'text-gray-400'}`} />
          </div>

          <h3 className={`${isMobile ? 'text-base' : 'text-lg'} font-semibold mb-3 ${isDarkMode ? 'text-white' : 'text-gray-900'}`}>
            D√©but de votre conversation
          </h3>

          <p className={`text-sm mb-6 ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}>
            Envoyez votre premier message pour commencer √† discuter !
          </p>

          <div className={`p-4 rounded-lg ${isDarkMode ? 'bg-purple-900/20 border border-purple-800/30' : 'bg-purple-50 border border-purple-200'}`}>
            <p className={`text-xs ${isDarkMode ? 'text-purple-300' : 'text-purple-700'}`}>
              üí° Cette conversation a √©t√© cr√©√©e suite √† l'acceptation d'une demande de miroir
            </p>
          </div>
        </div>
      </div>
    );
  }

  const messageGroups = groupMessagesByDate(messages);
  const groupEntries = Object.entries(messageGroups).sort(([a], [b]) =>
    new Date(a).getTime() - new Date(b).getTime()
  );

  return (
    <div
      ref={scrollAreaRef}
      className={`h-full overflow-y-auto ${isMobile ? 'p-3' : 'p-4'} space-y-4 ${isDarkMode ? 'bg-gray-900' : 'bg-gray-50'}`}
      style={{ scrollBehavior: 'smooth' }}
    >
      {groupEntries.map(([dateString, dayMessages]) => (
        <div key={dateString} className="space-y-3">

          {/* S√©parateur de date */}
          <div className="flex items-center justify-center">
            <div className={`${isMobile ? 'px-3 py-1.5' : 'px-4 py-2'} rounded-full ${isMobile ? 'text-xs' : 'text-xs'} font-medium ${
              isDarkMode
                ? 'bg-gray-800 text-gray-400 border border-gray-700'
                : 'bg-white text-gray-600 border border-gray-200 shadow-sm'
            }`}>
              {formatDateHeader(dateString)}
            </div>
          </div>

          {/* Messages du jour */}
          <div className={isMobile ? 'space-y-2' : 'space-y-3'}>
            {dayMessages.map((message, index) => {
              const prevMessage = index > 0 ? dayMessages[index - 1] : null;
              const isGrouped = prevMessage &&
                prevMessage.sender_id === message.sender_id &&
                new Date(message.created_at).getTime() - new Date(prevMessage.created_at).getTime() < 5 * 60 * 1000; // 5 minutes

              return (
                <MessageBubble
                  key={message.id}
                  message={message}
                  onReactToMessage={onReactToMessage}
                  onDeleteMessage={onDeleteMessage}
                  isDarkMode={isDarkMode}
                  isGrouped={isGrouped}
                  isMobile={isMobile}
                />
              );
            })}
          </div>
        </div>
      ))}

      {/* Ancre pour auto-scroll */}
      <div ref={bottomRef} />
    </div>
  );
};// =============================================


--- - ---

// COMPOSANTS UI TEMPS R√âEL - frontend/src/components/chat/TypingIndicator.tsx
// =============================================

import React from 'react';

interface TypingUser {
  userId: string;
  userName: string;
  conversationId: string;
  timestamp: number;
}

interface TypingIndicatorProps {
  typingUsers: TypingUser[];
  isDarkMode: boolean;
  className?: string;
}

export const TypingIndicator: React.FC<TypingIndicatorProps> = ({
  typingUsers,
  isDarkMode,
  className = ''
}) => {
  if (typingUsers.length === 0) return null;

  const getTypingText = () => {
    if (typingUsers.length === 1) {
      return `${typingUsers[0].userName} est en train d'√©crire...`;
    } else if (typingUsers.length === 2) {
      return `${typingUsers[0].userName} et ${typingUsers[1].userName} sont en train d'√©crire...`;
    } else {
      return `${typingUsers.length} personnes sont en train d'√©crire...`;
    }
  };

  return (
    <div className={`flex items-center gap-2 px-4 py-2 ${className}`}>
      {/* Animation de points qui bougent */}
      <div className="flex items-center gap-1">
        <div className={`w-2 h-2 rounded-full animate-bounce ${
          isDarkMode ? 'bg-gray-400' : 'bg-gray-500'
        }`} style={{ animationDelay: '0ms' }}></div>
        <div className={`w-2 h-2 rounded-full animate-bounce ${
          isDarkMode ? 'bg-gray-400' : 'bg-gray-500'
        }`} style={{ animationDelay: '150ms' }}></div>
        <div className={`w-2 h-2 rounded-full animate-bounce ${
          isDarkMode ? 'bg-gray-400' : 'bg-gray-500'
        }`} style={{ animationDelay: '300ms' }}></div>
      </div>

      {/* Texte */}
      <span className={`text-sm italic ${
        isDarkMode ? 'text-gray-400' : 'text-gray-600'
      }`}>
        {getTypingText()}
      </span>
    </div>
  );
};

// =============================================


--- - ---

// COMPOSANT STATUT EN LIGNE - frontend/src/components/chat/OnlineStatus.tsx
// =============================================

interface OnlineStatusProps {
  isOnline: boolean;
  lastSeen?: string;
  showText?: boolean;
  size?: 'sm' | 'md' | 'lg';
  className?: string;
}

export const OnlineStatus: React.FC<OnlineStatusProps> = ({
  isOnline,
  lastSeen,
  showText = false,
  size = 'md',
  className = ''
}) => {
  const sizeClasses = {
    sm: 'w-2 h-2',
    md: 'w-3 h-3',
    lg: 'w-4 h-4'
  };

  const formatLastSeen = (lastSeenDate: string) => {
    const date = new Date(lastSeenDate);
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMins = Math.floor(diffMs / (1000 * 60));
    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

    if (diffMins < 1) return '√Ä l\'instant';
    if (diffMins < 60) return `Il y a ${diffMins} min`;
    if (diffHours < 24) return `Il y a ${diffHours}h`;
    if (diffDays === 1) return 'Hier';
    if (diffDays < 7) return `Il y a ${diffDays} jours`;
    return date.toLocaleDateString('fr-FR');
  };

  return (
    <div className={`flex items-center gap-2 ${className}`}>
      {/* Indicateur visuel */}
      <div className="relative">
        <div className={`
          rounded-full border-2 border-white dark:border-gray-800
          ${sizeClasses[size]}
          ${isOnline
            ? 'bg-green-500 shadow-lg shadow-green-500/50'
            : 'bg-gray-400'
          }
        `}></div>

        {/* Animation de pulsation si en ligne */}
        {isOnline && (
          <div className={`
            absolute inset-0 rounded-full
            bg-green-500 animate-ping opacity-75
            ${sizeClasses[size]}
          `}></div>
        )}
      </div>

      {/* Texte du statut */}
      {showText && (
        <span className="text-xs text-gray-600 dark:text-gray-400">
          {isOnline ? 'En ligne' : lastSeen ? formatLastSeen(lastSeen) : 'Hors ligne'}
        </span>
      )}
    </div>
  );
};

// =============================================


--- - ---

// COMPOSANT INT√âGR√â POUR MESSAGESINPUT - frontend/src/components/chat/MessageInputWithTyping.tsx
// =============================================

import { useState, useRef, useEffect } from 'react';
import { Send, Paperclip, Mic, Image, Smile } from 'lucide-react';

interface MessageInputWithTypingProps {
  onSendMessage: (content: string, replyToId?: string) => void;
  onTypingChange: (isTyping: boolean) => void;
  isDarkMode: boolean;
  disabled?: boolean;
  placeholder?: string;
  replyTo?: any;
  onCancelReply?: () => void;
}

export const MessageInputWithTyping: React.FC<MessageInputWithTypingProps> = ({
  onSendMessage,
  onTypingChange,
  isDarkMode,
  disabled = false,
  placeholder = "Tapez votre message...",
  replyTo,
  onCancelReply
}) => {
  const [message, setMessage] = useState('');
  const [isTyping, setIsTyping] = useState(false);
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const typingTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // G√©rer l'indicateur de frappe
  const handleTypingIndicator = (typing: boolean) => {
    if (typing !== isTyping) {
      setIsTyping(typing);
      onTypingChange(typing);
    }

    if (typing) {
      // Arr√™ter l'indicateur apr√®s 3 secondes d'inactivit√©
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
      }

      typingTimeoutRef.current = setTimeout(() => {
        setIsTyping(false);
        onTypingChange(false);
      }, 3000);
    }
  };

  // G√©rer les changements de texte
  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const value = e.target.value;
    setMessage(value);

    // Indicateur de frappe
    if (value.trim()) {
      handleTypingIndicator(true);
    } else {
      handleTypingIndicator(false);
    }

    // Auto-resize du textarea
    if (textareaRef.current) {
      textareaRef.current.style.height = 'auto';
      textareaRef.current.style.height = `${Math.min(textareaRef.current.scrollHeight, 120)}px`;
    }
  };

  // Envoyer le message
  const handleSend = () => {
    const trimmedMessage = message.trim();
    if (!trimmedMessage || disabled) return;

    // Arr√™ter l'indicateur de frappe
    handleTypingIndicator(false);

    // Envoyer le message
    onSendMessage(trimmedMessage, replyTo?.id);

    // Reset
    setMessage('');
    if (textareaRef.current) {
      textareaRef.current.style.height = 'auto';
      textareaRef.current.focus();
    }
  };

  // G√©rer les touches clavier
  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  };

  // Nettoyage
  useEffect(() => {
    return () => {
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
      }
    };
  }, []);

  return (
    <div className={`border-t ${isDarkMode ? 'border-gray-700 bg-gray-800' : 'border-gray-200 bg-white'}`}>
      {/* Zone de r√©ponse */}
      {replyTo && (
        <div className={`px-4 py-2 border-l-4 border-purple-500 ${
          isDarkMode ? 'bg-gray-700' : 'bg-gray-50'
        }`}>
          <div className="flex items-center justify-between">
            <div>
              <p className={`text-xs font-medium ${
                isDarkMode ? 'text-purple-400' : 'text-purple-600'
              }`}>
                R√©ponse √† {replyTo.sender?.name || 'Utilisateur'}
              </p>
              <p className={`text-sm truncate ${
                isDarkMode ? 'text-gray-300' : 'text-gray-700'
              }`}>
                {replyTo.content || 'Message'}
              </p>
            </div>
            <button
              onClick={onCancelReply}
              className={`text-xs px-2 py-1 rounded ${
                isDarkMode
                  ? 'text-gray-400 hover:text-white hover:bg-gray-600'
                  : 'text-gray-600 hover:text-gray-900 hover:bg-gray-200'
              }`}
            >
              ‚úï
            </button>
          </div>
        </div>
      )}

      {/* Zone de saisie */}
      <div className="p-4">
        <div className={`flex items-end gap-3 p-3 rounded-2xl ${
          isDarkMode ? 'bg-gray-700' : 'bg-gray-100'
        }`}>

          {/* Bouton pi√®ce jointe */}
          <button
            disabled={disabled}
            className={`p-2 rounded-full transition-colors ${
              disabled
                ? 'text-gray-400 cursor-not-allowed'
                : isDarkMode
                  ? 'text-gray-400 hover:text-white hover:bg-gray-600'
                  : 'text-gray-600 hover:text-gray-900 hover:bg-gray-200'
            }`}
          >
            <Paperclip className="w-5 h-5" />
          </button>

          {/* Zone de texte */}
          <div className="flex-1">
            <textarea
              ref={textareaRef}
              value={message}
              onChange={handleChange}
              onKeyDown={handleKeyDown}
              placeholder={placeholder}
              disabled={disabled}
              rows={1}
              className={`
                w-full resize-none border-none outline-none bg-transparent
                text-sm placeholder-gray-500 min-h-[24px] max-h-[120px]
                ${isDarkMode ? 'text-white' : 'text-gray-900'}
                ${disabled ? 'cursor-not-allowed' : ''}
              `}
            />
          </div>

          {/* Boutons d'action */}
          <div className="flex items-center gap-2">
            {/* Bouton emoji */}
            <button
              disabled={disabled}
              className={`p-2 rounded-full transition-colors ${
                disabled
                  ? 'text-gray-400 cursor-not-allowed'
                  : isDarkMode
                    ? 'text-gray-400 hover:text-white hover:bg-gray-600'
                    : 'text-gray-600 hover:text-gray-900 hover:bg-gray-200'
              }`}
            >
              <Smile className="w-5 h-5" />
            </button>

            {/* Bouton envoyer / micro */}
            {message.trim() ? (
              <button
                onClick={handleSend}
                disabled={disabled}
                className={`p-2 rounded-full transition-all duration-200 ${
                  disabled
                    ? 'bg-gray-400 cursor-not-allowed'
                    : 'bg-gradient-to-r from-purple-600 to-pink-600 hover:shadow-lg hover:scale-105'
                } text-white`}
              >
                <Send className="w-5 h-5" />
              </button>
            ) : (
              <button
                disabled={disabled}
                className={`p-2 rounded-full transition-colors ${
                  disabled
                    ? 'text-gray-400 cursor-not-allowed'
                    : isDarkMode
                      ? 'text-gray-400 hover:text-white hover:bg-gray-600'
                      : 'text-gray-600 hover:text-gray-900 hover:bg-gray-200'
                }`}
              >
                <Mic className="w-5 h-5" />
              </button>
            )}
          </div>
        </div>

        {/* Indicateur de frappe local */}
        {isTyping && (
          <div className="mt-2 px-3">
            <span className={`text-xs ${
              isDarkMode ? 'text-gray-400' : 'text-gray-600'
            }`}>
              Vous tapez...
            </span>
          </div>
        )}
      </div>
    </div>
  );
};

// =============================================


--- - ---

// COMPOSANT LISTE DE CONVERSATIONS AVEC STATUTS - frontend/src/components/chat/ConversationItemWithStatus.tsx
// =============================================

interface ConversationItemWithStatusProps {
  conversation: any;
  isSelected: boolean;
  onClick: () => void;
  isOnline: boolean;
  hasUnread: boolean;
  isDarkMode: boolean;
}

export const ConversationItemWithStatus: React.FC<ConversationItemWithStatusProps> = ({
  conversation,
  isSelected,
  onClick,
  isOnline,
  hasUnread,
  isDarkMode
}) => {
  const formatTime = (dateStr: string) => {
    const date = new Date(dateStr);
    const now = new Date();
    const diffHours = (now.getTime() - date.getTime()) / (1000 * 60 * 60);

    if (diffHours < 24) {
      return date.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
    } else if (diffHours < 24 * 7) {
      return date.toLocaleDateString('fr-FR', { weekday: 'short' });
    } else {
      return date.toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit' });
    }
  };

  const getLastMessagePreview = () => {
    if (!conversation.last_message) return 'Nouvelle conversation';

    const msg = conversation.last_message;
    if (msg.message_type === 'image') return 'üì∑ Photo';
    if (msg.message_type === 'voice') return 'üé§ Message vocal';
    if (msg.message_type === 'system') return '‚öôÔ∏è ' + (msg.content || 'Message syst√®me');

    return msg.content || 'Message';
  };

  return (
    <div
      onClick={onClick}
      className={`
        p-4 cursor-pointer transition-all duration-200 border-l-4
        ${isSelected
          ? isDarkMode
            ? 'bg-gray-700 border-purple-500'
            : 'bg-purple-50 border-purple-500'
          : isDarkMode
            ? 'bg-gray-800 border-transparent hover:bg-gray-700'
            : 'bg-white border-transparent hover:bg-gray-50'
        }
      `}
    >
      <div className="flex items-center gap-3">
        {/* Avatar avec statut en ligne */}
        <div className="relative">
          {conversation.other_participant?.avatar_url ? (
            <img
              src={conversation.other_participant.avatar_url}
              alt={conversation.other_participant.name}
              className="w-12 h-12 rounded-full object-cover"
            />
          ) : (
            <div className="w-12 h-12 rounded-full bg-gradient-to-br from-purple-500 to-pink-500 flex items-center justify-center">
              <span className="text-white font-bold text-lg">
                {conversation.other_participant?.name?.charAt(0).toUpperCase() || '?'}
              </span>
            </div>
          )}

          {/* Statut en ligne */}
          <OnlineStatus
            isOnline={isOnline}
            size="sm"
            className="absolute -bottom-1 -right-1"
          />
        </div>

        {/* Contenu de la conversation */}
        <div className="flex-1 min-w-0">
          <div className="flex items-center justify-between mb-1">
            <h3 className={`font-semibold truncate ${
              isDarkMode ? 'text-white' : 'text-gray-900'
            }`}>
              {conversation.other_participant?.name || 'Utilisateur'}
            </h3>

            <span className={`text-xs ${
              hasUnread
                ? 'text-purple-600 dark:text-purple-400 font-medium'
                : isDarkMode ? 'text-gray-400' : 'text-gray-600'
            }`}>
              {formatTime(conversation.last_message_at || conversation.created_at)}
            </span>
          </div>

          <div className="flex items-center justify-between">
            <p className={`text-sm truncate flex-1 ${
              hasUnread
                ? isDarkMode ? 'text-gray-200 font-medium' : 'text-gray-800 font-medium'
                : isDarkMode ? 'text-gray-400' : 'text-gray-600'
            }`}>
              {getLastMessagePreview()}
            </p>

            {/* Badge de messages non lus */}
            {hasUnread && conversation.unread_count > 0 && (
              <div className="ml-2 min-w-[20px] h-5 bg-gradient-to-r from-purple-600 to-pink-600 rounded-full flex items-center justify-center">
                <span className="text-white text-xs font-bold px-1">
                  {conversation.unread_count > 99 ? '99+' : conversation.unread_count}
                </span>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
};// =============================================


--- - ---

// HOOK CHAT TEMPS R√âEL CORRIG√â - frontend/src/hooks/useChat.ts
// =============================================

import { useState, useEffect, useCallback, useRef } from 'react';
import { useAuth } from '../contexts/AuthContext';
import { chatService } from '../services/chatService';
import { chatWebSocketService } from '../services/chatWebSocket';
import type { Conversation, Message, ChatStats, SendMessageParams } from '../../../shared/types/chat';

// Interface pour les indicateurs de frappe
interface TypingUser {
  userId: string;
  userName: string;
  conversationId: string;
  timestamp: number;
}

export const useChat = () => {
  const { user } = useAuth();

  // √âtats principaux
  const [conversations, setConversations] = useState<Conversation[]>([]);
  const [currentConversation, setCurrentConversation] = useState<Conversation | null>(null);
  const [messages, setMessages] = useState<Message[]>([]);
  const [chatStats, setChatStats] = useState<ChatStats>({ total_unread_conversations: 0 });

  // √âtats de chargement
  const [isLoading, setIsLoading] = useState(false);
  const [isLoadingMessages, setIsLoadingMessages] = useState(false);
  const [isConnected, setIsConnected] = useState(false);

  // √âtats temps r√©el
  const [typingUsers, setTypingUsers] = useState<TypingUser[]>([]);
  const [onlineUsers, setOnlineUsers] = useState<Set<string>>(new Set());

  // Refs pour √©viter les re-renders excessifs et r√©f√©rences circulaires
  const typingTimeoutRef = useRef<Map<string, NodeJS.Timeout>>(new Map());
  const isTypingRef = useRef(false);
  const lastTypingTimeRef = useRef(0);

  // ‚úÖ FIX : Refs pour √©viter les r√©f√©rences circulaires
  const loadConversationsRef = useRef<(() => Promise<void>) | null>(null);
  const currentConversationRef = useRef<Conversation | null>(null);

  // Synchroniser les refs avec les states
  useEffect(() => {
    currentConversationRef.current = currentConversation;
  }, [currentConversation]);

  // ============ M√âTHODES PRINCIPALES (ordre correct) ============

  /**
   * Charger les conversations
   */
  const loadConversations = useCallback(async () => {
    if (!user) return;

    try {
      setIsLoading(true);
      console.log('üîÑ useChat: Chargement conversations...');

      const data = await chatService.getConversations();
      setConversations(data);

      console.log('‚úÖ useChat: Conversations charg√©es:', data.length);
    } catch (error) {
      console.error('‚ùå useChat: Erreur chargement conversations:', error);
    } finally {
      setIsLoading(false);
    }
  }, [user]);

  // ‚úÖ Assigner la ref apr√®s d√©finition
  useEffect(() => {
    loadConversationsRef.current = loadConversations;
  }, [loadConversations]);

  /**
   * Charger les messages d'une conversation
   */
  const loadMessages = useCallback(async (conversationId: string) => {
    if (!user) return;

    try {
      setIsLoadingMessages(true);
      console.log('üîÑ useChat: Chargement messages conversation:', conversationId);

      const data = await chatService.getMessages(conversationId);

      // Enrichir les messages
      const enrichedMessages = data.map(msg => ({
        ...msg,
        is_own_message: msg.sender_id === user.id,
        is_expired: chatService.isMessageExpired(msg)
      }));

      setMessages(enrichedMessages);

      // Marquer comme lu si des messages existent
      if (enrichedMessages.length > 0) {
        const lastMessage = enrichedMessages[enrichedMessages.length - 1];
        if (!lastMessage.is_own_message) {
          await chatService.markAsRead(conversationId, lastMessage.id);
          chatWebSocketService.markAsReadRealtime(conversationId, lastMessage.id);
        }
      }

      console.log('‚úÖ useChat: Messages charg√©s:', enrichedMessages.length);
    } catch (error) {
      console.error('‚ùå useChat: Erreur chargement messages:', error);
      setMessages([]);
    } finally {
      setIsLoadingMessages(false);
    }
  }, [user]);

  /**
   * Charger les stats
   */
  const loadChatStats = useCallback(async () => {
    if (!user) return;

    try {
      console.log('üîÑ useChat: Chargement stats...');
      const stats = await chatService.getChatStats();
      setChatStats(stats);
      console.log('‚úÖ useChat: Stats charg√©es:', stats);
    } catch (error) {
      console.error('‚ùå useChat: Erreur chargement stats:', error);
    }
  }, [user]);

  // ============ WEBSOCKET SETUP (apr√®s les m√©thodes principales) ============

  /**
   * Nettoyer les listeners WebSocket
   */
  const cleanupWebSocketListeners = useCallback(() => {
    console.log('üßπ useChat: Nettoyage listeners WebSocket');

    // Nettoyer tous les timeouts de frappe
    typingTimeoutRef.current.forEach(timeout => clearTimeout(timeout));
    typingTimeoutRef.current.clear();
  }, []);

  /**
   * Configurer les listeners WebSocket
   */
  const setupWebSocketListeners = useCallback(() => {
    console.log('üéß useChat: Configuration listeners WebSocket...');

    // ============ √âV√âNEMENTS CONNEXION ============

    chatWebSocketService.on('connect', () => {
      console.log('‚úÖ useChat: WebSocket connect√©');
      setIsConnected(true);
    });

    chatWebSocketService.on('disconnect', (reason) => {
      console.log('‚ùå useChat: WebSocket d√©connect√©:', reason);
      setIsConnected(false);
    });

    chatWebSocketService.on('connect_error', (error) => {
      console.error('‚ùå useChat: Erreur connexion WebSocket:', error);
      setIsConnected(false);
    });

    // ============ √âV√âNEMENTS MESSAGES ============

    chatWebSocketService.on('new_message', ({ conversationId, message }) => {
      console.log('üì® useChat: Nouveau message re√ßu');

      // Enrichir le message
      const enrichedMessage = {
        ...message,
        is_own_message: message.sender_id === user?.id,
        is_expired: chatService.isMessageExpired(message)
      };

      // Ajouter √† la liste si c'est la conversation courante
      if (currentConversationRef.current?.id === conversationId) {
        setMessages(prev => [...prev, enrichedMessage]);

        // Marquer comme lu automatiquement si visible
        if (!enrichedMessage.is_own_message) {
          chatService.markAsRead(conversationId, message.id);
          chatWebSocketService.markAsReadRealtime(conversationId, message.id);
        }
      }

      // ‚úÖ FIX : Utiliser la ref pour √©viter la r√©f√©rence circulaire
      if (loadConversationsRef.current) {
        loadConversationsRef.current();
      }
    });

    chatWebSocketService.on('message_updated', ({ conversationId, message }) => {
      console.log('‚úèÔ∏è useChat: Message modifi√© re√ßu');

      if (currentConversationRef.current?.id === conversationId) {
        setMessages(prev =>
          prev.map(msg =>
            msg.id === message.id
              ? {
                  ...message,
                  is_own_message: msg.is_own_message,
                  is_expired: msg.is_expired
                }
              : msg
          )
        );
      }
    });

    chatWebSocketService.on('message_deleted', ({ conversationId, messageId }) => {
      console.log('üóëÔ∏è useChat: Message supprim√© re√ßu');

      if (currentConversationRef.current?.id === conversationId) {
        setMessages(prev => prev.filter(msg => msg.id !== messageId));
      }
    });

    chatWebSocketService.on('message_reaction', ({ conversationId, messageId, emoji, action, userId }) => {
      console.log('üòä useChat: R√©action re√ßue');

      if (currentConversationRef.current?.id === conversationId) {
        setMessages(prev =>
          prev.map(msg => {
            if (msg.id === messageId) {
              const reactions = { ...msg.reactions };

              if (action === 'add') {
                if (!reactions[emoji]) reactions[emoji] = [];
                if (!reactions[emoji].includes(userId)) {
                  reactions[emoji].push(userId);
                }
              } else {
                if (reactions[emoji]) {
                  reactions[emoji] = reactions[emoji].filter(id => id !== userId);
                  if (reactions[emoji].length === 0) {
                    delete reactions[emoji];
                  }
                }
              }

              return { ...msg, reactions };
            }
            return msg;
          })
        );
      }
    });

    // ============ √âV√âNEMENTS CONVERSATIONS ============

    chatWebSocketService.on('new_conversation', ({ conversation }) => {
      console.log('üí¨ useChat: Nouvelle conversation re√ßue');
      if (loadConversationsRef.current) {
        loadConversationsRef.current();
      }
    });

    // ============ √âV√âNEMENTS PR√âSENCE ============

    chatWebSocketService.on('user_typing', ({ conversationId, userId, userName, isTyping }) => {
      console.log(`‚å®Ô∏è useChat: ${userName} ${isTyping ? 'tape' : 'arr√™te'} dans ${conversationId}`);

      if (userId === user?.id) return; // Ignorer ses propres indicateurs

      setTypingUsers(prev => {
        if (isTyping) {
          // Ajouter ou mettre √† jour l'utilisateur qui tape
          const filtered = prev.filter(u => u.userId !== userId || u.conversationId !== conversationId);
          return [...filtered, {
            userId,
            userName,
            conversationId,
            timestamp: Date.now()
          }];
        } else {
          // Retirer l'utilisateur
          return prev.filter(u => u.userId !== userId || u.conversationId !== conversationId);
        }
      });

      // Auto-nettoyage apr√®s 5 secondes
      if (isTyping) {
        const key = `${userId}-${conversationId}`;
        const existingTimeout = typingTimeoutRef.current.get(key);
        if (existingTimeout) clearTimeout(existingTimeout);

        const timeout = setTimeout(() => {
          setTypingUsers(prev => prev.filter(u => u.userId !== userId || u.conversationId !== conversationId));
          typingTimeoutRef.current.delete(key);
        }, 5000);

        typingTimeoutRef.current.set(key, timeout);
      }
    });

    chatWebSocketService.on('user_online', ({ userId, isOnline }) => {
      setOnlineUsers(prev => {
        const newSet = new Set(prev);
        if (isOnline) {
          newSet.add(userId);
        } else {
          newSet.delete(userId);
        }
        return newSet;
      });
    });

  }, [user]); // ‚úÖ D√©pendances minimales

  /**
   * Initialiser la connexion WebSocket
   */
  const initializeWebSocket = useCallback(async () => {
    if (!user) return;

    try {
      console.log('üåê useChat: Initialisation WebSocket...');

      // Se connecter au WebSocket
      await chatWebSocketService.connect(user.id);
      setIsConnected(true);

      console.log('‚úÖ useChat: WebSocket connect√©');

    } catch (error) {
      console.error('‚ùå useChat: Erreur connexion WebSocket:', error);
      setIsConnected(false);
    }
  }, [user]);

  // ============ ACTIONS UTILISATEUR ============

  /**
   * S√©lectionner une conversation
   */
  const selectConversation = useCallback((conversation: Conversation) => {
    console.log('üëÜ useChat: S√©lection conversation:', conversation.id);

    // Quitter l'ancienne conversation
    if (currentConversation) {
      chatWebSocketService.leaveConversation(currentConversation.id);
    }

    // Entrer dans la nouvelle conversation
    setCurrentConversation(conversation);
    chatWebSocketService.joinConversation(conversation.id);
    loadMessages(conversation.id);

    // Reset des indicateurs de frappe pour cette conversation
    setTypingUsers(prev => prev.filter(u => u.conversationId !== conversation.id));
  }, [currentConversation, loadMessages]);

  /**
   * Envoyer un message
   */
  const sendMessage = useCallback(async (conversationId: string, params: SendMessageParams) => {
    if (!user) return;

    try {
      console.log('üì§ useChat: Envoi message:', { conversationId, params });

      // Arr√™ter l'indicateur de frappe
      if (isTypingRef.current) {
        chatWebSocketService.sendTypingIndicator(conversationId, false);
        isTypingRef.current = false;
      }

      const newMessage = await chatService.sendMessage(conversationId, params);

      // Feedback imm√©diat
      const enrichedMessage = {
        ...newMessage,
        is_own_message: true,
        is_expired: false
      };

      setMessages(prev => [...prev, enrichedMessage]);

      // Recharger les conversations
      if (loadConversationsRef.current) {
        await loadConversationsRef.current();
      }

      console.log('‚úÖ useChat: Message envoy√©:', newMessage.id);

    } catch (error) {
      console.error('‚ùå useChat: Erreur envoi message:', error);
      throw error;
    }
  }, [user]);

  /**
   * R√©agir √† un message
   */
  const reactToMessage = useCallback(async (messageId: string, emoji: string, action: 'add' | 'remove' = 'add') => {
    try {
      await chatService.reactToMessage(messageId, emoji, action);

      // Update optimiste
      setMessages(prev =>
        prev.map(msg => {
          if (msg.id === messageId && user) {
            const reactions = { ...msg.reactions };

            if (action === 'add') {
              if (!reactions[emoji]) reactions[emoji] = [];
              if (!reactions[emoji].includes(user.id)) {
                reactions[emoji].push(user.id);
              }
            } else {
              if (reactions[emoji]) {
                reactions[emoji] = reactions[emoji].filter(id => id !== user.id);
                if (reactions[emoji].length === 0) {
                  delete reactions[emoji];
                }
              }
            }

            return { ...msg, reactions };
          }
          return msg;
        })
      );

    } catch (error) {
      console.error('‚ùå useChat: Erreur r√©action message:', error);
      throw error;
    }
  }, [user]);

  /**
   * Supprimer un message
   */
  const deleteMessage = useCallback(async (messageId: string) => {
    try {
      await chatService.deleteMessage(messageId);
      setMessages(prev => prev.filter(msg => msg.id !== messageId));
    } catch (error) {
      console.error('‚ùå useChat: Erreur suppression message:', error);
      throw error;
    }
  }, []);

  /**
   * Marquer comme lu
   */
  const markAsRead = useCallback(async (conversationId: string, lastMessageId: string) => {
    try {
      await chatService.markAsRead(conversationId, lastMessageId);
      chatWebSocketService.markAsReadRealtime(conversationId, lastMessageId);

      if (loadConversationsRef.current) {
        await loadConversationsRef.current();
      }
    } catch (error) {
      console.error('‚ùå useChat: Erreur marquage lu:', error);
    }
  }, []);

  /**
   * Cr√©er une nouvelle conversation
   */
  const createConversation = useCallback(async (participantId: string) => {
    if (!user) return null;

    try {
      const conversation = await chatService.createConversation(participantId);

      if (loadConversationsRef.current) {
        await loadConversationsRef.current();
      }
      selectConversation(conversation);

      return conversation;
    } catch (error) {
      console.error('‚ùå useChat: Erreur cr√©ation conversation:', error);
      throw error;
    }
  }, [user, selectConversation]);

  // ============ INDICATEURS DE FRAPPE ============

  const sendTypingIndicator = useCallback((conversationId: string, isTyping: boolean) => {
    if (!isConnected || !currentConversation) return;

    const now = Date.now();

    if (isTyping) {
      if (now - lastTypingTimeRef.current < 1000) return;
      lastTypingTimeRef.current = now;
    }

    if (isTypingRef.current !== isTyping) {
      isTypingRef.current = isTyping;
      chatWebSocketService.sendTypingIndicator(conversationId, isTyping);
    }
  }, [isConnected, currentConversation]);

  const getCurrentTypingUsers = useCallback(() => {
    if (!currentConversation) return [];

    return typingUsers.filter(u =>
      u.conversationId === currentConversation.id &&
      Date.now() - u.timestamp < 5000
    );
  }, [currentConversation, typingUsers]);

  // ============ EFFECTS ============

  useEffect(() => {
    if (user) {
      console.log('üèÅ useChat: Init pour utilisateur:', user.id);

      loadConversations();
      loadChatStats();
      initializeWebSocket();
      setupWebSocketListeners();

    } else {
      console.log('üõë useChat: Reset');

      cleanupWebSocketListeners();
      chatWebSocketService.disconnect();

      setConversations([]);
      setCurrentConversation(null);
      setMessages([]);
      setChatStats({ total_unread_conversations: 0 });
      setIsConnected(false);
      setTypingUsers([]);
      setOnlineUsers(new Set());
    }

    return () => {
      cleanupWebSocketListeners();
    };
  }, [user, loadConversations, loadChatStats, initializeWebSocket, setupWebSocketListeners, cleanupWebSocketListeners]);

  useEffect(() => {
    if (currentConversation && conversations.length > 0) {
      const stillExists = conversations.find(c => c.id === currentConversation.id);
      if (!stillExists) {
        setCurrentConversation(null);
        setMessages([]);
      }
    }
  }, [conversations, currentConversation]);

  // ============ M√âTHODES UTILITAIRES ============

  const getChatStats = useCallback(async (): Promise<ChatStats> => {
    try {
      return await chatService.getChatStats();
    } catch (error) {
      return { total_unread_conversations: 0 };
    }
  }, []);

  const refreshConversations = useCallback(() => {
    loadConversations();
  }, [loadConversations]);

  const refreshMessages = useCallback(() => {
    if (currentConversation) {
      loadMessages(currentConversation.id);
    }
  }, [currentConversation, loadMessages]);

  const isUserOnline = useCallback((userId: string): boolean => {
    return onlineUsers.has(userId);
  }, [onlineUsers]);

  return {
    // √âtat principal
    conversations,
    currentConversation,
    messages,
    chatStats,
    isLoading,
    isLoadingMessages,
    isConnected,

    // √âtat temps r√©el
    typingUsers: getCurrentTypingUsers(),
    onlineUsers,

    // Actions principales
    loadConversations,
    loadMessages,
    loadChatStats,
    selectConversation,
    sendMessage,
    reactToMessage,
    deleteMessage,
    markAsRead,
    createConversation,

    // Actions temps r√©el
    sendTypingIndicator,

    // Actions utilitaires
    getChatStats,
    refreshConversations,
    refreshMessages,
    isUserOnline,

    // Setters directs
    setCurrentConversation,
    setMessages,
    setChatStats
  };
};
// =============================================


--- - ---

// HOOK CHAT TEMPS R√âEL - frontend/src/hooks/useChat.ts
// =============================================

import { useState, useEffect, useCallback, useRef } from 'react';
import { useAuth } from '../contexts/AuthContext';
import { chatService } from '../services/chatService';
import { chatWebSocketService } from '../services/chatWebSocket';
import type { Conversation, Message, ChatStats, SendMessageParams } from '../../../shared/types/chat';

// Interface pour les indicateurs de frappe
interface TypingUser {
  userId: string;
  userName: string;
  conversationId: string;
  timestamp: number;
}

export const useChat = () => {
  const { user } = useAuth();

  // √âtats principaux
  const [conversations, setConversations] = useState<Conversation[]>([]);
  const [currentConversation, setCurrentConversation] = useState<Conversation | null>(null);
  const [messages, setMessages] = useState<Message[]>([]);
  const [chatStats, setChatStats] = useState<ChatStats>({ total_unread_conversations: 0 });

  // √âtats de chargement
  const [isLoading, setIsLoading] = useState(false);
  const [isLoadingMessages, setIsLoadingMessages] = useState(false);
  const [isConnected, setIsConnected] = useState(false);

  // √âtats temps r√©el
  const [typingUsers, setTypingUsers] = useState<TypingUser[]>([]);
  const [onlineUsers, setOnlineUsers] = useState<Set<string>>(new Set());

  // Refs pour √©viter les re-renders excessifs
  const typingTimeoutRef = useRef<Map<string, NodeJS.Timeout>>(new Map());
  const isTypingRef = useRef(false);
  const lastTypingTimeRef = useRef(0);

  // ============ WEBSOCKET SETUP ============

  /**
   * Initialiser la connexion WebSocket
   */
  const initializeWebSocket = useCallback(async () => {
    if (!user) return;

    try {
      console.log('üåê useChat: Initialisation WebSocket...');

      // Se connecter au WebSocket
      await chatWebSocketService.connect(user.id);
      setIsConnected(true);

      console.log('‚úÖ useChat: WebSocket connect√©');

    } catch (error) {
      console.error('‚ùå useChat: Erreur connexion WebSocket:', error);
      setIsConnected(false);
    }
  }, [user]);

  /**
   * Configurer les listeners WebSocket
   */
  const setupWebSocketListeners = useCallback(() => {
    console.log('üéß useChat: Configuration listeners WebSocket...');

    // ============ √âV√âNEMENTS CONNEXION ============

    chatWebSocketService.on('connect', () => {
      console.log('‚úÖ useChat: WebSocket connect√©');
      setIsConnected(true);
    });

    chatWebSocketService.on('disconnect', (reason) => {
      console.log('‚ùå useChat: WebSocket d√©connect√©:', reason);
      setIsConnected(false);
    });

    chatWebSocketService.on('connect_error', (error) => {
      console.error('‚ùå useChat: Erreur connexion WebSocket:', error);
      setIsConnected(false);
    });

    // ============ √âV√âNEMENTS MESSAGES ============

    chatWebSocketService.on('new_message', ({ conversationId, message }) => {
      console.log('üì® useChat: Nouveau message re√ßu');

      // Enrichir le message
      const enrichedMessage = {
        ...message,
        is_own_message: message.sender_id === user?.id,
        is_expired: chatService.isMessageExpired(message)
      };

      // Ajouter √† la liste si c'est la conversation courante
      if (currentConversation?.id === conversationId) {
        setMessages(prev => [...prev, enrichedMessage]);

        // Marquer comme lu automatiquement si visible
        if (!enrichedMessage.is_own_message) {
          chatService.markAsRead(conversationId, message.id);
          chatWebSocketService.markAsReadRealtime(conversationId, message.id);
        }
      }

      // Recharger les conversations pour mettre √† jour les compteurs
      loadConversations();
    });

    chatWebSocketService.on('message_updated', ({ conversationId, message }) => {
      console.log('‚úèÔ∏è useChat: Message modifi√© re√ßu');

      if (currentConversation?.id === conversationId) {
        setMessages(prev =>
          prev.map(msg =>
            msg.id === message.id
              ? {
                  ...message,
                  is_own_message: msg.is_own_message,
                  is_expired: msg.is_expired
                }
              : msg
          )
        );
      }
    });

    chatWebSocketService.on('message_deleted', ({ conversationId, messageId }) => {
      console.log('üóëÔ∏è useChat: Message supprim√© re√ßu');

      if (currentConversation?.id === conversationId) {
        setMessages(prev => prev.filter(msg => msg.id !== messageId));
      }
    });

    chatWebSocketService.on('message_reaction', ({ conversationId, messageId, emoji, action, userId }) => {
      console.log('üòä useChat: R√©action re√ßue');

      if (currentConversation?.id === conversationId) {
        setMessages(prev =>
          prev.map(msg => {
            if (msg.id === messageId) {
              const reactions = { ...msg.reactions };

              if (action === 'add') {
                if (!reactions[emoji]) reactions[emoji] = [];
                if (!reactions[emoji].includes(userId)) {
                  reactions[emoji].push(userId);
                }
              } else {
                if (reactions[emoji]) {
                  reactions[emoji] = reactions[emoji].filter(id => id !== userId);
                  if (reactions[emoji].length === 0) {
                    delete reactions[emoji];
                  }
                }
              }

              return { ...msg, reactions };
            }
            return msg;
          })
        );
      }
    });

    // ============ √âV√âNEMENTS CONVERSATIONS ============

    chatWebSocketService.on('new_conversation', ({ conversation }) => {
      console.log('üí¨ useChat: Nouvelle conversation re√ßue');
      loadConversations(); // Recharger la liste
    });

    // ============ √âV√âNEMENTS PR√âSENCE ============

    chatWebSocketService.on('user_typing', ({ conversationId, userId, userName, isTyping }) => {
      console.log(`‚å®Ô∏è useChat: ${userName} ${isTyping ? 'tape' : 'arr√™te'} dans ${conversationId}`);

      if (userId === user?.id) return; // Ignorer ses propres indicateurs

      setTypingUsers(prev => {
        if (isTyping) {
          // Ajouter ou mettre √† jour l'utilisateur qui tape
          const filtered = prev.filter(u => u.userId !== userId || u.conversationId !== conversationId);
          return [...filtered, {
            userId,
            userName,
            conversationId,
            timestamp: Date.now()
          }];
        } else {
          // Retirer l'utilisateur
          return prev.filter(u => u.userId !== userId || u.conversationId !== conversationId);
        }
      });

      // Auto-nettoyage apr√®s 5 secondes (au cas o√π l'√©v√©nement stop se perd)
      if (isTyping) {
        const key = `${userId}-${conversationId}`;
        const existingTimeout = typingTimeoutRef.current.get(key);
        if (existingTimeout) clearTimeout(existingTimeout);

        const timeout = setTimeout(() => {
          setTypingUsers(prev => prev.filter(u => u.userId !== userId || u.conversationId !== conversationId));
          typingTimeoutRef.current.delete(key);
        }, 5000);

        typingTimeoutRef.current.set(key, timeout);
      }
    });

    chatWebSocketService.on('user_online', ({ userId, isOnline }) => {
      setOnlineUsers(prev => {
        const newSet = new Set(prev);
        if (isOnline) {
          newSet.add(userId);
        } else {
          newSet.delete(userId);
        }
        return newSet;
      });
    });

    chatWebSocketService.on('message_read_by_user', ({ userId, messageId, conversationId }) => {
      console.log(`‚úÖ useChat: Message ${messageId} lu par ${userId}`);
      // TODO: Ajouter des indicateurs de lecture si n√©cessaire
    });

  }, [user, currentConversation, loadConversations]);

  /**
   * Nettoyer les listeners WebSocket
   */
  const cleanupWebSocketListeners = useCallback(() => {
    console.log('üßπ useChat: Nettoyage listeners WebSocket');

    // Nettoyer tous les timeouts de frappe
    typingTimeoutRef.current.forEach(timeout => clearTimeout(timeout));
    typingTimeoutRef.current.clear();

    // Note: Les listeners WebSocket sont automatiquement nettoy√©s
    // quand on appelle disconnect()
  }, []);

  // ============ M√âTHODES PRINCIPALES ============

  /**
   * Charger les conversations
   */
  const loadConversations = useCallback(async () => {
    if (!user) return;

    try {
      setIsLoading(true);
      console.log('üîÑ useChat: Chargement conversations...');

      const data = await chatService.getConversations();
      setConversations(data);

      console.log('‚úÖ useChat: Conversations charg√©es:', data.length);
    } catch (error) {
      console.error('‚ùå useChat: Erreur chargement conversations:', error);
    } finally {
      setIsLoading(false);
    }
  }, [user]);

  /**
   * Charger les messages d'une conversation
   */
  const loadMessages = useCallback(async (conversationId: string) => {
    if (!user) return;

    try {
      setIsLoadingMessages(true);
      console.log('üîÑ useChat: Chargement messages conversation:', conversationId);

      const data = await chatService.getMessages(conversationId);

      // Enrichir les messages
      const enrichedMessages = data.map(msg => ({
        ...msg,
        is_own_message: msg.sender_id === user.id,
        is_expired: chatService.isMessageExpired(msg)
      }));

      setMessages(enrichedMessages);

      // Marquer comme lu si des messages existent
      if (enrichedMessages.length > 0) {
        const lastMessage = enrichedMessages[enrichedMessages.length - 1];
        if (!lastMessage.is_own_message) {
          await chatService.markAsRead(conversationId, lastMessage.id);
          chatWebSocketService.markAsReadRealtime(conversationId, lastMessage.id);
        }
      }

      console.log('‚úÖ useChat: Messages charg√©s:', enrichedMessages.length);
    } catch (error) {
      console.error('‚ùå useChat: Erreur chargement messages:', error);
      setMessages([]);
    } finally {
      setIsLoadingMessages(false);
    }
  }, [user]);

  /**
   * Charger les stats
   */
  const loadChatStats = useCallback(async () => {
    if (!user) return;

    try {
      console.log('üîÑ useChat: Chargement stats...');
      const stats = await chatService.getChatStats();
      setChatStats(stats);
      console.log('‚úÖ useChat: Stats charg√©es:', stats);
    } catch (error) {
      console.error('‚ùå useChat: Erreur chargement stats:', error);
    }
  }, [user]);

  /**
   * S√©lectionner une conversation
   */
  const selectConversation = useCallback((conversation: Conversation) => {
    console.log('üëÜ useChat: S√©lection conversation:', conversation.id);

    // Quitter l'ancienne conversation
    if (currentConversation) {
      chatWebSocketService.leaveConversation(currentConversation.id);
    }

    // Entrer dans la nouvelle conversation
    setCurrentConversation(conversation);
    chatWebSocketService.joinConversation(conversation.id);
    loadMessages(conversation.id);

    // Reset des indicateurs de frappe pour cette conversation
    setTypingUsers(prev => prev.filter(u => u.conversationId !== conversation.id));
  }, [currentConversation, loadMessages]);

  /**
   * Envoyer un message
   */
  const sendMessage = useCallback(async (conversationId: string, params: SendMessageParams) => {
    if (!user) return;

    try {
      console.log('üì§ useChat: Envoi message:', { conversationId, params });

      // Arr√™ter l'indicateur de frappe
      if (isTypingRef.current) {
        chatWebSocketService.sendTypingIndicator(conversationId, false);
        isTypingRef.current = false;
      }

      const newMessage = await chatService.sendMessage(conversationId, params);

      // Le message sera automatiquement ajout√© via WebSocket
      // Mais on l'ajoute quand m√™me pour un feedback imm√©diat
      const enrichedMessage = {
        ...newMessage,
        is_own_message: true,
        is_expired: false
      };

      setMessages(prev => [...prev, enrichedMessage]);

      // Recharger les conversations pour l'ordre et les compteurs
      await loadConversations();

      console.log('‚úÖ useChat: Message envoy√©:', newMessage.id);

    } catch (error) {
      console.error('‚ùå useChat: Erreur envoi message:', error);
      throw error;
    }
  }, [user, loadConversations]);

  /**
   * R√©agir √† un message
   */
  const reactToMessage = useCallback(async (messageId: string, emoji: string, action: 'add' | 'remove' = 'add') => {
    try {
      console.log('üòä useChat: R√©action message:', { messageId, emoji, action });

      await chatService.reactToMessage(messageId, emoji, action);

      // La mise √† jour sera re√ßue via WebSocket, mais on peut faire un update optimiste
      setMessages(prev =>
        prev.map(msg => {
          if (msg.id === messageId && user) {
            const reactions = { ...msg.reactions };

            if (action === 'add') {
              if (!reactions[emoji]) reactions[emoji] = [];
              if (!reactions[emoji].includes(user.id)) {
                reactions[emoji].push(user.id);
              }
            } else {
              if (reactions[emoji]) {
                reactions[emoji] = reactions[emoji].filter(id => id !== user.id);
                if (reactions[emoji].length === 0) {
                  delete reactions[emoji];
                }
              }
            }

            return { ...msg, reactions };
          }
          return msg;
        })
      );

      console.log('‚úÖ useChat: R√©action ajout√©e');

    } catch (error) {
      console.error('‚ùå useChat: Erreur r√©action message:', error);
      throw error;
    }
  }, [user]);

  /**
   * Supprimer un message
   */
  const deleteMessage = useCallback(async (messageId: string) => {
    try {
      console.log('üóëÔ∏è useChat: Suppression message:', messageId);

      await chatService.deleteMessage(messageId);

      // Update optimiste - le WebSocket confirmera
      setMessages(prev => prev.filter(msg => msg.id !== messageId));

      console.log('‚úÖ useChat: Message supprim√©');

    } catch (error) {
      console.error('‚ùå useChat: Erreur suppression message:', error);
      throw error;
    }
  }, []);

  /**
   * Marquer comme lu
   */
  const markAsRead = useCallback(async (conversationId: string, lastMessageId: string) => {
    try {
      console.log('‚úÖ useChat: Marquage lu:', { conversationId, lastMessageId });

      await chatService.markAsRead(conversationId, lastMessageId);
      chatWebSocketService.markAsReadRealtime(conversationId, lastMessageId);
      await loadConversations(); // Recharger pour les compteurs

    } catch (error) {
      console.error('‚ùå useChat: Erreur marquage lu:', error);
    }
  }, [loadConversations]);

  /**
   * Cr√©er une nouvelle conversation
   */
  const createConversation = useCallback(async (participantId: string) => {
    if (!user) return null;

    try {
      console.log('üí¨ useChat: Cr√©ation conversation avec:', participantId);

      const conversation = await chatService.createConversation(participantId);

      await loadConversations();
      selectConversation(conversation);

      console.log('‚úÖ useChat: Conversation cr√©√©e:', conversation.id);
      return conversation;

    } catch (error) {
      console.error('‚ùå useChat: Erreur cr√©ation conversation:', error);
      throw error;
    }
  }, [user, loadConversations, selectConversation]);

  // ============ INDICATEURS DE FRAPPE ============

  /**
   * Envoyer un indicateur de frappe (throttled)
   */
  const sendTypingIndicator = useCallback((conversationId: string, isTyping: boolean) => {
    if (!isConnected || !currentConversation) return;

    const now = Date.now();

    if (isTyping) {
      // Throttle: max 1 fois par seconde
      if (now - lastTypingTimeRef.current < 1000) return;
      lastTypingTimeRef.current = now;
    }

    if (isTypingRef.current !== isTyping) {
      isTypingRef.current = isTyping;
      chatWebSocketService.sendTypingIndicator(conversationId, isTyping);
    }
  }, [isConnected, currentConversation]);

  /**
   * Obtenir les utilisateurs qui tapent dans la conversation courante
   */
  const getCurrentTypingUsers = useCallback(() => {
    if (!currentConversation) return [];

    return typingUsers.filter(u =>
      u.conversationId === currentConversation.id &&
      Date.now() - u.timestamp < 5000 // Pas plus de 5 secondes
    );
  }, [currentConversation, typingUsers]);

  // ============ EFFECTS ============

  /**
   * Initialisation et nettoyage
   */
  useEffect(() => {
    if (user) {
      console.log('üèÅ useChat: Init pour utilisateur:', user.id);

      // Charger les donn√©es initiales
      loadConversations();
      loadChatStats();

      // Initialiser WebSocket
      initializeWebSocket();
      setupWebSocketListeners();

    } else {
      console.log('üõë useChat: Reset (plus d\'utilisateur)');

      // Nettoyer
      cleanupWebSocketListeners();
      chatWebSocketService.disconnect();

      // Reset des donn√©es
      setConversations([]);
      setCurrentConversation(null);
      setMessages([]);
      setChatStats({ total_unread_conversations: 0 });
      setIsConnected(false);
      setTypingUsers([]);
      setOnlineUsers(new Set());
    }

    return () => {
      cleanupWebSocketListeners();
    };
  }, [user, initializeWebSocket, setupWebSocketListeners, cleanupWebSocketListeners, loadConversations, loadChatStats]);

  /**
   * Reset conversation courante si elle dispara√Æt de la liste
   */
  useEffect(() => {
    if (currentConversation && conversations.length > 0) {
      const stillExists = conversations.find(c => c.id === currentConversation.id);
      if (!stillExists) {
        console.log('‚ö†Ô∏è useChat: Conversation courante plus dans la liste, reset');
        setCurrentConversation(null);
        setMessages([]);
      }
    }
  }, [conversations, currentConversation]);

  // ============ M√âTHODES UTILITAIRES ============

  const getChatStats = useCallback(async (): Promise<ChatStats> => {
    try {
      return await chatService.getChatStats();
    } catch (error) {
      console.error('‚ùå useChat: Erreur getChatStats:', error);
      return { total_unread_conversations: 0 };
    }
  }, []);

  const refreshConversations = useCallback(() => {
    console.log('üîÑ useChat: Refresh manuel conversations');
    loadConversations();
  }, [loadConversations]);

  const refreshMessages = useCallback(() => {
    if (currentConversation) {
      console.log('üîÑ useChat: Refresh manuel messages');
      loadMessages(currentConversation.id);
    }
  }, [currentConversation, loadMessages]);

  const isUserOnline = useCallback((userId: string): boolean => {
    return onlineUsers.has(userId);
  }, [onlineUsers]);

  return {
    // √âtat principal
    conversations,
    currentConversation,
    messages,
    chatStats,
    isLoading,
    isLoadingMessages,
    isConnected,

    // √âtat temps r√©el
    typingUsers: getCurrentTypingUsers(),
    onlineUsers,

    // Actions principales
    loadConversations,
    loadMessages,
    loadChatStats,
    selectConversation,
    sendMessage,
    reactToMessage,
    deleteMessage,
    markAsRead,
    createConversation,

    // Actions temps r√©el
    sendTypingIndicator,

    // Actions utilitaires
    getChatStats,
    refreshConversations,
    refreshMessages,
    isUserOnline,

    // Setters directs (pour des cas sp√©ciaux)
    setCurrentConversation,
    setMessages,
    setChatStats
  };
};// =============================================


--- - ---

// HOOK WEBSOCKET CHAT - frontend/src/hooks/useChatWebSocket.ts
// =============================================

import { useEffect, useCallback, useState } from 'react';
import { useAuth } from '../contexts/AuthContext';
import { chatWebSocketService } from '../services/chatWebSocket';
import type { Message, Conversation } from '../../../shared/types/chat';

interface ChatWebSocketHook {
  isConnected: boolean;
  connect: () => void;
  disconnect: () => void;
  joinConversation: (conversationId: string) => void;
  leaveConversation: (conversationId: string) => void;
  sendTypingIndicator: (conversationId: string, isTyping: boolean) => void;
}

interface WebSocketEventHandlers {
  onNewMessage?: (data: { conversationId: string; message: Message }) => void;
  onMessageUpdated?: (data: { conversationId: string; message: Message }) => void;
  onMessageDeleted?: (data: { conversationId: string; messageId: string }) => void;
  onMessageReaction?: (data: {
    conversationId: string;
    messageId: string;
    emoji: string;
    action: 'add' | 'remove';
    userId: string;
  }) => void;
  onNewConversation?: (data: { conversation: Conversation }) => void;
  onUserTyping?: (data: {
    conversationId: string;
    userId: string;
    userName: string;
    isTyping: boolean;
  }) => void;
  onUserOnline?: (data: { userId: string; isOnline: boolean }) => void;
  onConnect?: () => void;
  onDisconnect?: (reason: string) => void;
  onConnectError?: (error: Error) => void;
}

export const useChatWebSocket = (handlers: WebSocketEventHandlers = {}): ChatWebSocketHook => {
  const { user } = useAuth();
  const [isConnected, setIsConnected] = useState(false);

  // ============ √âV√âNEMENTS WEBSOCKET ============

  useEffect(() => {
    // √âv√©nements de connexion
    const handleConnect = () => {
      console.log('‚úÖ useChatWebSocket: Connect√©');
      setIsConnected(true);
      handlers.onConnect?.();
    };

    const handleDisconnect = (reason: string) => {
      console.log('‚ùå useChatWebSocket: D√©connect√©:', reason);
      setIsConnected(false);
      handlers.onDisconnect?.(reason);
    };

    const handleConnectError = (error: Error) => {
      console.error('‚ùå useChatWebSocket: Erreur connexion:', error);
      setIsConnected(false);
      handlers.onConnectError?.(error);
    };

    // √âv√©nements de messages
    const handleNewMessage = (data: { conversationId: string; message: Message }) => {
      console.log('üì® useChatWebSocket: Nouveau message');
      handlers.onNewMessage?.(data);
    };

    const handleMessageUpdated = (data: { conversationId: string; message: Message }) => {
      console.log('‚úèÔ∏è useChatWebSocket: Message modifi√©');
      handlers.onMessageUpdated?.(data);
    };

    const handleMessageDeleted = (data: { conversationId: string; messageId: string }) => {
      console.log('üóëÔ∏è useChatWebSocket: Message supprim√©');
      handlers.onMessageDeleted?.(data);
    };

    const handleMessageReaction = (data: any) => {
      console.log('üòä useChatWebSocket: R√©action message');
      handlers.onMessageReaction?.(data);
    };

    // √âv√©nements de conversations
    const handleNewConversation = (data: { conversation: Conversation }) => {
      console.log('üí¨ useChatWebSocket: Nouvelle conversation');
      handlers.onNewConversation?.(data);
    };

    // √âv√©nements de pr√©sence
    const handleUserTyping = (data: any) => {
      handlers.onUserTyping?.(data);
    };

    const handleUserOnline = (data: any) => {
      handlers.onUserOnline?.(data);
    };

    // Abonner aux √©v√©nements
    chatWebSocketService.on('connect', handleConnect);
    chatWebSocketService.on('disconnect', handleDisconnect);
    chatWebSocketService.on('connect_error', handleConnectError);
    chatWebSocketService.on('new_message', handleNewMessage);
    chatWebSocketService.on('message_updated', handleMessageUpdated);
    chatWebSocketService.on('message_deleted', handleMessageDeleted);
    chatWebSocketService.on('message_reaction', handleMessageReaction);
    chatWebSocketService.on('new_conversation', handleNewConversation);
    chatWebSocketService.on('user_typing', handleUserTyping);
    chatWebSocketService.on('user_online', handleUserOnline);

    // Nettoyage
    return () => {
      chatWebSocketService.off('connect', handleConnect);
      chatWebSocketService.off('disconnect', handleDisconnect);
      chatWebSocketService.off('connect_error', handleConnectError);
      chatWebSocketService.off('new_message', handleNewMessage);
      chatWebSocketService.off('message_updated', handleMessageUpdated);
      chatWebSocketService.off('message_deleted', handleMessageDeleted);
      chatWebSocketService.off('message_reaction', handleMessageReaction);
      chatWebSocketService.off('new_conversation', handleNewConversation);
      chatWebSocketService.off('user_typing', handleUserTyping);
      chatWebSocketService.off('user_online', handleUserOnline);
    };
  }, [handlers]);

  // ============ CONNEXION AUTOMATIQUE ============

  useEffect(() => {
    if (user && !isConnected) {
      console.log('üîå useChatWebSocket: Connexion automatique pour:', user.id);
      chatWebSocketService.connect(user.id).catch(error => {
        console.error('‚ùå useChatWebSocket: Erreur connexion auto:', error);
      });
    }

    // D√©connecter quand plus d'utilisateur
    return () => {
      if (!user) {
        console.log('üîå useChatWebSocket: D√©connexion (plus d\'utilisateur)');
        chatWebSocketService.disconnect();
        setIsConnected(false);
      }
    };
  }, [user, isConnected]);

  // ============ ACTIONS ============

  const connect = useCallback(() => {
    if (user) {
      console.log('üîå useChatWebSocket: Connexion manuelle');
      chatWebSocketService.connect(user.id).catch(error => {
        console.error('‚ùå useChatWebSocket: Erreur connexion manuelle:', error);
      });
    }
  }, [user]);

  const disconnect = useCallback(() => {
    console.log('üîå useChatWebSocket: D√©connexion manuelle');
    chatWebSocketService.disconnect();
    setIsConnected(false);
  }, []);

  const joinConversation = useCallback((conversationId: string) => {
    console.log('üè† useChatWebSocket: Rejoindre conversation:', conversationId);
    chatWebSocketService.joinConversation(conversationId);
  }, []);

  const leaveConversation = useCallback((conversationId: string) => {
    console.log('üö™ useChatWebSocket: Quitter conversation:', conversationId);
    chatWebSocketService.leaveConversation(conversationId);
  }, []);

  const sendTypingIndicator = useCallback((conversationId: string, isTyping: boolean) => {
    chatWebSocketService.sendTypingIndicator(conversationId, isTyping);
  }, []);

  return {
    isConnected,
    connect,
    disconnect,
    joinConversation,
    leaveConversation,
    sendTypingIndicator
  };
};

// ============ HOOK SIMPLIFI√â POUR LES COMPOSANTS ============

/**
 * Hook simplifi√© pour int√©grer les WebSockets dans les composants de chat
 */
export const useChatRealtime = (
  currentConversationId?: string,
  onNewMessage?: (message: Message) => void,
  onMessageUpdated?: (message: Message) => void,
  onMessageDeleted?: (messageId: string) => void
) => {
  const [typingUsers, setTypingUsers] = useState<Array<{ userId: string; userName: string }>>([]);
  const [onlineUsers, setOnlineUsers] = useState<Set<string>>(new Set());

  const webSocket = useChatWebSocket({
    onNewMessage: (data) => {
      // Seulement pour la conversation courante
      if (data.conversationId === currentConversationId) {
        onNewMessage?.(data.message);
      }
    },

    onMessageUpdated: (data) => {
      if (data.conversationId === currentConversationId) {
        onMessageUpdated?.(data.message);
      }
    },

    onMessageDeleted: (data) => {
      if (data.conversationId === currentConversationId) {
        onMessageDeleted?.(data.messageId);
      }
    },

    onUserTyping: (data) => {
      if (data.conversationId === currentConversationId) {
        setTypingUsers(prev => {
          const filtered = prev.filter(u => u.userId !== data.userId);
          if (data.isTyping) {
            return [...filtered, { userId: data.userId, userName: data.userName }];
          }
          return filtered;
        });
      }
    },

    onUserOnline: (data) => {
      setOnlineUsers(prev => {
        const newSet = new Set(prev);
        if (data.isOnline) {
          newSet.add(data.userId);
        } else {
          newSet.delete(data.userId);
        }
        return newSet;
      });
    }
  });

  // Rejoindre/quitter la conversation courante
  useEffect(() => {
    if (currentConversationId && webSocket.isConnected) {
      webSocket.joinConversation(currentConversationId);

      return () => {
        webSocket.leaveConversation(currentConversationId);
      };
    }
  }, [currentConversationId, webSocket.isConnected]);

  return {
    ...webSocket,
    typingUsers,
    onlineUsers,
    isUserOnline: (userId: string) => onlineUsers.has(userId)
  };
};import { authManager } from './authManager'
import type {
  Conversation,
  Message,
  SendMessageParams,
  ChatStats,
  CreateConversationParams,
  UpdateMessageParams,
  ReactToMessageParams
} from '../../../shared/types/chat'

const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:3001'

class ChatService {
  private async getAuthHeaders(): Promise<Record<string, string>> {
    const token = await authManager.getAccessToken()

    if (!token) {
      throw new Error('No access token available')
    }

    return {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${token}`
    }
  }

  private async handleResponse(response: Response): Promise<any> {
    if (response.status === 401) {
      await authManager.clearSession()
      window.location.href = '/login'
      throw new Error('Authentication required')
    }

    if (!response.ok) {
      throw new Error(`Chat API Error: ${response.status}`)
    }

    const result = await response.json()
    if (!result.success) {
      throw new Error(result.error || 'Chat operation failed')
    }

    return result.data
  }

  // ============ M√âTHODES CONVERSATIONS ============

  async getConversations(limit = 20, offset = 0): Promise<Conversation[]> {
    try {
      const headers = await this.getAuthHeaders()
      const response = await fetch(`${API_BASE_URL}/api/chat/conversations?limit=${limit}&offset=${offset}`, { headers })
      return this.handleResponse(response)
    } catch (error) {
      console.error('‚ùå getConversations error:', error)
      throw error
    }
  }

  async getConversation(conversationId: string): Promise<Conversation> {
    try {
      const headers = await this.getAuthHeaders()
      const response = await fetch(`${API_BASE_URL}/api/chat/conversations/${conversationId}`, { headers })
      return this.handleResponse(response)
    } catch (error) {
      console.error('‚ùå getConversation error:', error)
      throw error
    }
  }

  async createConversation(participantId: string): Promise<Conversation> {
    try {
      const headers = await this.getAuthHeaders()
      const response = await fetch(`${API_BASE_URL}/api/chat/conversations`, {
        method: 'POST',
        headers,
        body: JSON.stringify({ participant_id: participantId })
      })
      return this.handleResponse(response)
    } catch (error) {
      console.error('‚ùå createConversation error:', error)
      throw error
    }
  }

  // ============ M√âTHODES MESSAGES ============

  async getMessages(conversationId: string, limit = 50, offset = 0): Promise<Message[]> {
    try {
      const headers = await this.getAuthHeaders()
      const response = await fetch(`${API_BASE_URL}/api/chat/conversations/${conversationId}/messages?limit=${limit}&offset=${offset}`, { headers })
      return this.handleResponse(response)
    } catch (error) {
      console.error('‚ùå getMessages error:', error)
      throw error
    }
  }

  async sendMessage(conversationId: string, params: SendMessageParams): Promise<Message> {
    try {
      const headers = await this.getAuthHeaders()
      const response = await fetch(`${API_BASE_URL}/api/chat/conversations/${conversationId}/messages`, {
        method: 'POST',
        headers,
        body: JSON.stringify(params)
      })
      return this.handleResponse(response)
    } catch (error) {
      console.error('‚ùå sendMessage error:', error)
      throw error
    }
  }

  async updateMessage(messageId: string, params: UpdateMessageParams): Promise<Message> {
    try {
      const headers = await this.getAuthHeaders()
      const response = await fetch(`${API_BASE_URL}/api/chat/messages/${messageId}`, {
        method: 'PUT',
        headers,
        body: JSON.stringify(params)
      })
      return this.handleResponse(response)
    } catch (error) {
      console.error('‚ùå updateMessage error:', error)
      throw error
    }
  }

  async deleteMessage(messageId: string): Promise<boolean> {
    try {
      const headers = await this.getAuthHeaders()
      const response = await fetch(`${API_BASE_URL}/api/chat/messages/${messageId}`, {
        method: 'DELETE',
        headers
      })
      await this.handleResponse(response)
      return true
    } catch (error) {
      console.error('‚ùå deleteMessage error:', error)
      throw error
    }
  }

  async reactToMessage(messageId: string, emoji: string, action: 'add' | 'remove' = 'add'): Promise<Message> {
    try {
      const headers = await this.getAuthHeaders()
      const response = await fetch(`${API_BASE_URL}/api/chat/messages/${messageId}/react`, {
        method: 'POST',
        headers,
        body: JSON.stringify({ emoji, action })
      })
      return this.handleResponse(response)
    } catch (error) {
      console.error('‚ùå reactToMessage error:', error)
      throw error
    }
  }

  // ‚úÖ M√âTHODE AJOUT√âE - R√©cup√©rer les r√©actions d'un message
  getMessageReactions(message: Message): Record<string, string[]> {
    return message?.reactions || {}
  }

  // ============ M√âTHODES LECTURES ============

  async markAsRead(conversationId: string, lastMessageId: string): Promise<void> {
    try {
      const headers = await this.getAuthHeaders()
      await fetch(`${API_BASE_URL}/api/chat/conversations/${conversationId}/read`, {
        method: 'POST',
        headers,
        body: JSON.stringify({ last_message_id: lastMessageId })
      })
    } catch (error) {
      console.error('‚ùå markAsRead error:', error)
      // Ne pas faire planter l'app pour √ßa
    }
  }

  async getUnreadCount(conversationId: string): Promise<number> {
    try {
      const headers = await this.getAuthHeaders()
      const response = await fetch(`${API_BASE_URL}/api/chat/conversations/${conversationId}/unread-count`, { headers })
      const result = await this.handleResponse(response)
      return result.unread_count || 0
    } catch (error) {
      console.error('‚ùå getUnreadCount error:', error)
      return 0
    }
  }

  // ============ M√âTHODES STATS ============

  async getChatStats(): Promise<ChatStats> {
    try {
      const headers = await this.getAuthHeaders()
      const response = await fetch(`${API_BASE_URL}/api/chat/stats`, { headers })
      return this.handleResponse(response)
    } catch (error) {
      console.error('‚ùå getChatStats error:', error)
      throw error
    }
  }

  // ============ M√âTHODES UTILITAIRES ============

  isMessageExpired(message: Message): boolean {
    if (!message.expires_at) return false
    return new Date(message.expires_at) < new Date()
  }

  formatMessageTime(message: Message): string {
    const date = new Date(message.created_at)
    return date.toLocaleTimeString('fr-FR', {
      hour: '2-digit',
      minute: '2-digit'
    })
  }

  formatMessageDate(message: Message): string {
    const date = new Date(message.created_at)
    const today = new Date()
    const yesterday = new Date(today)
    yesterday.setDate(yesterday.getDate() - 1)

    if (date.toDateString() === today.toDateString()) {
      return 'Aujourd\'hui'
    } else if (date.toDateString() === yesterday.toDateString()) {
      return 'Hier'
    } else {
      return date.toLocaleDateString('fr-FR', {
        day: 'numeric',
        month: 'short'
      })
    }
  }

  getLastMessagePreview(message: Message): string {
    if (message.message_type === 'image') {
      return 'üì∑ Image'
    } else if (message.message_type === 'voice') {
      return 'üé§ Message vocal'
    } else if (message.message_type === 'system') {
      return '‚öôÔ∏è Message syst√®me'
    } else {
      return message.content || 'Message'
    }
  }

  // ============ M√âTHODES DE VALIDATION ============

  validateMessageContent(content: string): boolean {
    return content.trim().length > 0 && content.length <= 4000
  }

  validateMediaFile(file: File): { valid: boolean; error?: string } {
    const maxSize = 10 * 1024 * 1024 // 10MB
    const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp']

    if (file.size > maxSize) {
      return { valid: false, error: 'Le fichier est trop volumineux (max 10MB)' }
    }

    if (!allowedTypes.includes(file.type)) {
      return { valid: false, error: 'Type de fichier non support√©' }
    }

    return { valid: true }
  }

  validateVoiceFile(file: File): { valid: boolean; error?: string } {
    const maxSize = 5 * 1024 * 1024 // 5MB
    const allowedTypes = ['audio/mp3', 'audio/wav', 'audio/m4a', 'audio/ogg']

    if (file.size > maxSize) {
      return { valid: false, error: 'Le fichier audio est trop volumineux (max 5MB)' }
    }

    if (!allowedTypes.includes(file.type)) {
      return { valid: false, error: 'Type de fichier audio non support√©' }
    }

    return { valid: true }
  }

  // ============ M√âTHODES DE FILTRAGE ============

  filterActiveConversations(conversations: Conversation[]): Conversation[] {
    return conversations.filter(conv => conv.status === 'active')
  }

  sortConversationsByLastMessage(conversations: Conversation[]): Conversation[] {
    return [...conversations].sort((a, b) => {
      const dateA = new Date(a.last_message_at || a.created_at).getTime()
      const dateB = new Date(b.last_message_at || b.created_at).getTime()
      return dateB - dateA
    })
  }

  filterMessagesByType(messages: Message[], types: string[]): Message[] {
    return messages.filter(message => types.includes(message.message_type))
  }

  filterNonExpiredMessages(messages: Message[]): Message[] {
    return messages.filter(message => !this.isMessageExpired(message))
  }

  // ============ M√âTHODES DE RECHERCHE ============

  searchMessages(messages: Message[], query: string): Message[] {
    const searchTerm = query.toLowerCase().trim()
    if (!searchTerm) return messages

    return messages.filter(message => {
      if (message.message_type !== 'text' || !message.content) return false
      return message.content.toLowerCase().includes(searchTerm)
    })
  }

  searchConversations(conversations: Conversation[], query: string): Conversation[] {
    const searchTerm = query.toLowerCase().trim()
    if (!searchTerm) return conversations

    return conversations.filter(conversation => {
      const participantName = conversation.other_participant?.name?.toLowerCase()
      const lastMessageContent = conversation.last_message?.content?.toLowerCase()

      return (
        participantName?.includes(searchTerm) ||
        lastMessageContent?.includes(searchTerm)
      )
    })
  }

  // ============ M√âTHODES DE CACHE ============

  private messageCache = new Map<string, Message[]>()
  private conversationCache = new Map<string, Conversation>()

  getCachedMessages(conversationId: string): Message[] | null {
    return this.messageCache.get(conversationId) || null
  }

  setCachedMessages(conversationId: string, messages: Message[]): void {
    this.messageCache.set(conversationId, messages)
  }

  clearMessageCache(conversationId?: string): void {
    if (conversationId) {
      this.messageCache.delete(conversationId)
    } else {
      this.messageCache.clear()
    }
  }

  getCachedConversation(conversationId: string): Conversation | null {
    return this.conversationCache.get(conversationId) || null
  }

  setCachedConversation(conversation: Conversation): void {
    this.conversationCache.set(conversation.id, conversation)
  }

  clearConversationCache(): void {
    this.conversationCache.clear()
  }

  // ============ M√âTHODES DE NETTOYAGE ============

  cleanup(): void {
    this.clearMessageCache()
    this.clearConversationCache()
  }
}

export const chatService = new ChatService()// =============================================


--- - ---

// WEBSOCKET CHAT - frontend/src/services/chatWebSocket.ts
// =============================================

import { io, Socket } from 'socket.io-client';
import type { Message, Conversation } from '../../../shared/types/chat';

interface WebSocketEvents {
  // Messages
  new_message: (data: { conversationId: string; message: Message }) => void;
  message_updated: (data: { conversationId: string; message: Message }) => void;
  message_deleted: (data: { conversationId: string; messageId: string }) => void;
  message_reaction: (data: {
    conversationId: string;
    messageId: string;
    emoji: string;
    action: 'add' | 'remove';
    userId: string;
  }) => void;

  // Conversations
  new_conversation: (data: { conversation: Conversation }) => void;
  conversation_updated: (data: { conversation: Conversation }) => void;

  // Pr√©sence
  user_typing: (data: { conversationId: string; userId: string; userName: string; isTyping: boolean }) => void;
  user_online: (data: { userId: string; isOnline: boolean }) => void;

  // Syst√®me
  connect: () => void;
  disconnect: () => void;
  connect_error: (error: Error) => void;
}

class ChatWebSocketService {
  private socket: Socket | null = null;
  private isConnected = false;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private listeners: Map<string, Function[]> = new Map();

  constructor() {
    console.log('üåê ChatWebSocket: Service initialis√©');
  }

  /**
   * Se connecter au serveur WebSocket
   */
  async connect(userId: string): Promise<void> {
    try {
      console.log('üîå ChatWebSocket: Connexion pour utilisateur:', userId);

      // R√©cup√©rer le token d'auth
      const token = await this.getAuthToken();

      const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:3001';

      // Cr√©er la connexion Socket.IO
      this.socket = io(API_URL, {
        auth: {
          token,
          userId
        },
        transports: ['websocket', 'polling'],
        autoConnect: false
      });

      // √âv√©nements de connexion
      this.socket.on('connect', () => {
        console.log('‚úÖ ChatWebSocket: Connect√©');
        this.isConnected = true;
        this.reconnectAttempts = 0;
        this.emit('connect');
      });

      this.socket.on('disconnect', (reason) => {
        console.log('‚ùå ChatWebSocket: D√©connect√©:', reason);
        this.isConnected = false;
        this.emit('disconnect', reason);

        // Tentative de reconnexion automatique
        if (reason === 'io server disconnect') {
          // Le serveur a ferm√© la connexion, on doit se reconnecter manuellement
          this.reconnect();
        }
      });

      this.socket.on('connect_error', (error) => {
        console.error('‚ùå ChatWebSocket: Erreur connexion:', error);
        this.isConnected = false;
        this.emit('connect_error', error);
        this.reconnect();
      });

      // √âv√©nements chat
      this.setupChatEvents();

      // Se connecter
      this.socket.connect();

    } catch (error) {
      console.error('‚ùå ChatWebSocket: Erreur connect:', error);
      throw error;
    }
  }

  /**
   * Configurer les √©v√©nements du chat
   */
  private setupChatEvents(): void {
    if (!this.socket) return;

    // Nouveau message
    this.socket.on('new_message', (data: { conversationId: string; message: Message }) => {
      console.log('üì® ChatWebSocket: Nouveau message re√ßu');
      this.emit('new_message', data);
    });

    // Message modifi√©
    this.socket.on('message_updated', (data: { conversationId: string; message: Message }) => {
      console.log('‚úèÔ∏è ChatWebSocket: Message modifi√©');
      this.emit('message_updated', data);
    });

    // Message supprim√©
    this.socket.on('message_deleted', (data: { conversationId: string; messageId: string }) => {
      console.log('üóëÔ∏è ChatWebSocket: Message supprim√©');
      this.emit('message_deleted', data);
    });

    // R√©action √† un message
    this.socket.on('message_reaction', (data: any) => {
      console.log('üòä ChatWebSocket: R√©action re√ßue');
      this.emit('message_reaction', data);
    });

    // Nouvelle conversation
    this.socket.on('new_conversation', (data: { conversation: Conversation }) => {
      console.log('üí¨ ChatWebSocket: Nouvelle conversation');
      this.emit('new_conversation', data);
    });

    // Indicateur de frappe
    this.socket.on('user_typing', (data: any) => {
      this.emit('user_typing', data);
    });

    // Statut en ligne
    this.socket.on('user_online', (data: any) => {
      this.emit('user_online', data);
    });
  }

  /**
   * Se d√©connecter
   */
  disconnect(): void {
    console.log('üîå ChatWebSocket: D√©connexion');

    if (this.socket) {
      this.socket.disconnect();
      this.socket = null;
    }

    this.isConnected = false;
    this.listeners.clear();
  }

  /**
   * Rejoindre une conversation
   */
  joinConversation(conversationId: string): void {
    if (this.socket && this.isConnected) {
      console.log('üè† ChatWebSocket: Rejoindre conversation:', conversationId);
      this.socket.emit('join_conversation', { conversationId });
    }
  }

  /**
   * Quitter une conversation
   */
  leaveConversation(conversationId: string): void {
    if (this.socket && this.isConnected) {
      console.log('üö™ ChatWebSocket: Quitter conversation:', conversationId);
      this.socket.emit('leave_conversation', { conversationId });
    }
  }

  /**
   * Indiquer qu'on est en train de taper
   */
  sendTypingIndicator(conversationId: string, isTyping: boolean): void {
    if (this.socket && this.isConnected) {
      this.socket.emit('typing', { conversationId, isTyping });
    }
  }

  /**
   * Marquer des messages comme lus en temps r√©el
   */
  markAsReadRealtime(conversationId: string, messageId: string): void {
    if (this.socket && this.isConnected) {
      this.socket.emit('mark_read', { conversationId, messageId });
    }
  }

  // ============ SYST√àME D'√âV√âNEMENTS ============

  /**
   * S'abonner √† un √©v√©nement
   */
  on<K extends keyof WebSocketEvents>(event: K, callback: WebSocketEvents[K]): void {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }
    this.listeners.get(event)!.push(callback);
  }

  /**
   * Se d√©sabonner d'un √©v√©nement
   */
  off<K extends keyof WebSocketEvents>(event: K, callback: WebSocketEvents[K]): void {
    const eventListeners = this.listeners.get(event);
    if (eventListeners) {
      const index = eventListeners.indexOf(callback);
      if (index > -1) {
        eventListeners.splice(index, 1);
      }
    }
  }

  /**
   * √âmettre un √©v√©nement vers les listeners
   */
  private emit(event: string, ...args: any[]): void {
    const eventListeners = this.listeners.get(event);
    if (eventListeners) {
      eventListeners.forEach(callback => callback(...args));
    }
  }

  // ============ UTILITAIRES ============

  /**
   * Obtenir le statut de connexion
   */
  get connected(): boolean {
    return this.isConnected;
  }

  /**
   * Obtenir le socket (pour debug)
   */
  get socketInstance(): Socket | null {
    return this.socket;
  }

  /**
   * R√©cup√©rer le token d'auth
   */
  private async getAuthToken(): Promise<string> {
    const supabaseUrl = import.meta.env.VITE_SUPABASE_URL || 'https://qbcbeitvmtqwoifbkghy.supabase.co';
    const storageKey = `sb-${new URL(supabaseUrl).hostname.split('.')[0]}-auth-token`;

    const authData = localStorage.getItem(storageKey);
    if (!authData) {
      throw new Error('No authentication token found');
    }

    const parsedAuth = JSON.parse(authData);
    const accessToken = parsedAuth?.access_token;

    if (!accessToken) {
      throw new Error('No access token found');
    }

    return accessToken;
  }

  /**
   * Tentative de reconnexion
   */
  private reconnect(): void {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error('‚ùå ChatWebSocket: Max tentatives de reconnexion atteintes');
      return;
    }

    this.reconnectAttempts++;
    const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 10000);

    console.log(`üîÑ ChatWebSocket: Reconnexion dans ${delay}ms (tentative ${this.reconnectAttempts})`);

    setTimeout(() => {
      if (this.socket) {
        this.socket.connect();
      }
    }, delay);
  }
}

// Instance singleton
export const chatWebSocketService = new ChatWebSocketService();// =============================================


--- - ---

// TYPES PARTAG√âS - shared/types/chat.ts
// =============================================

export interface Conversation {
  id: string;
  participant_1_id: string;
  participant_2_id: string;
  created_at: string;
  last_message_at: string;
  last_message_id: string | null;
  status: 'active' | 'archived' | 'blocked';
  // Donn√©es enrichies c√¥t√© frontend
  other_participant?: {
    id: string;
    name: string;
    avatar_url: string | null;
  };
  unread_count?: number;
  last_message?: Message;
}

export interface Message {
  id: string;
  conversation_id: string;
  sender_id: string;
  content: string | null;
  message_type: 'text' | 'image' | 'voice' | 'system';
  media_url: string | null;
  media_metadata: any;
  reply_to_id: string | null;
  reactions: Record<string, string[]>; // {"‚ù§Ô∏è": ["user_id1"], "üòÇ": ["user_id2"]}
  expires_at: string | null;
  edited_at: string | null;
  deleted_at: string | null;
  created_at: string;
  updated_at: string;
  // Donn√©es enrichies c√¥t√© frontend
  sender?: {
    id: string;
    name: string;
    avatar_url: string | null;
  };
  reply_to?: Message;
  is_own_message?: boolean; // Calcul√© c√¥t√© frontend
  is_expired?: boolean; // Calcul√© c√¥t√© frontend
}

export interface MessageRead {
  id: string;
  conversation_id: string;
  user_id: string;
  last_read_message_id: string | null;
  read_at: string;
}

// ============ INTERFACES POUR LES PARAM√àTRES ============

export interface CreateConversationParams {
  participant_1_id: string;
  participant_2_id: string;
}

export interface SendMessageParams {
  content?: string;
  message_type?: 'text' | 'image' | 'voice';
  media_url?: string;
  media_metadata?: any;
  reply_to_id?: string;
  expires_in_minutes?: number;
}

export interface UpdateMessageParams {
  content?: string;
  media_url?: string;
  media_metadata?: any;
}

export interface ReactToMessageParams {
  emoji: string;
  action?: 'add' | 'remove';
}

export interface ChatStats {
  total_unread_conversations: number;
}

// ============ INTERFACES POUR LE CONTEXTE REACT ============

export interface ChatContextType {
  conversations: Conversation[];
  currentConversation: Conversation | null;
  messages: Message[];
  chatStats: ChatStats;
  isLoading: boolean;
  isLoadingMessages: boolean;
  isConnected: boolean; // WebSocket

  // Actions
  loadConversations: () => Promise<void>;
  loadConversation: (conversationId: string) => Promise<void>;
  loadMessages: (conversationId: string) => Promise<void>;
  sendMessage: (conversationId: string, params: SendMessageParams) => Promise<void>;
  markAsRead: (conversationId: string, lastMessageId: string) => Promise<void>;
  reactToMessage: (messageId: string, emoji: string, action?: 'add' | 'remove') => Promise<void>;
  deleteMessage: (messageId: string) => Promise<void>;

  // Navigation
  selectConversation: (conversation: Conversation) => void;

  // Stats
  getChatStats: () => Promise<ChatStats>;
}

// ============ INTERFACES WEBSOCKET ============

export interface WebSocketEvents {
  // Messages
  new_message: (data: { conversationId: string; message: Message; timestamp: string }) => void;
  message_updated: (data: { conversationId: string; message: Message; timestamp: string }) => void;
  message_deleted: (data: { conversationId: string; messageId: string; timestamp: string }) => void;
  message_reaction: (data: {
    conversationId: string;
    messageId: string;
    emoji: string;
    action: 'add' | 'remove';
    userId: string;
    timestamp: string;
  }) => void;

  // Conversations
  new_conversation: (data: { conversation: Conversation; timestamp: string }) => void;
  conversation_updated: (data: { conversationId: string; timestamp: string }) => void;

  // Pr√©sence
  user_typing: (data: { userId: string; userName: string; isTyping: boolean }) => void;
  message_read_by_user: (data: { userId: string; messageId: string; readAt: string }) => void;
  online_status_update: (data: Array<{ userId: string; isOnline: boolean; lastSeen: string }>) => void;

  // Syst√®me
  connect: () => void;
  disconnect: (reason: string) => void;
  connect_error: (error: Error) => void;
}

// ============ INTERFACES UPLOAD M√âDIAS ============

export interface UploadResult {
  success: boolean;
  url?: string;
  error?: string;
  metadata?: {
    size: number;
    type: string;
    duration?: number; // Pour l'audio
    width?: number; // Pour les images
    height?: number; // Pour les images
  };
}

export interface MediaMetadata {
  size: number;
  type: string;
  duration?: number;
  width?: number;
  height?: number;
  thumbnail_url?: string;
}

// ============ INTERFACES R√âACTIONS ============

export interface MessageReaction {
  emoji: string;
  count: number;
  users: string[];
  hasUserReacted?: boolean; // Calcul√© c√¥t√© frontend
}

// ============ INTERFACES TYPING INDICATORS ============

export interface TypingIndicator {
  userId: string;
  userName: string;
  isTyping: boolean;
  timestamp: string;
}

// ============ INTERFACES POUR LES COMPOSANTS ============

export interface ChatPageProps {
  isDarkMode: boolean;
}

export interface ConversationListProps {
  conversations: Conversation[];
  currentConversation: Conversation | null;
  onSelectConversation: (conversation: Conversation) => void;
  isDarkMode: boolean;
}

export interface ChatWindowProps {
  conversation: Conversation;
  messages: Message[];
  isLoadingMessages: boolean;
  onSendMessage: (content: string, replyToId?: string) => void;
  onReactToMessage: (messageId: string, emoji: string) => void;
  onDeleteMessage: (messageId: string) => void;
  isDarkMode: boolean;
}

export interface MessageListProps {
  messages: Message[];
  isLoading: boolean;
  onReactToMessage: (messageId: string, emoji: string) => void;
  onDeleteMessage: (messageId: string) => void;
  isDarkMode: boolean;
}

export interface MessageBubbleProps {
  message: Message;
  onReactToMessage: (messageId: string, emoji: string) => void;
  onDeleteMessage: (messageId: string) => void;
  isDarkMode: boolean;
}

export interface MessageInputProps {
  onSendMessage: (content: string, replyToId?: string) => void;
  isDarkMode: boolean;
  disabled?: boolean;
  placeholder?: string;
}

// ============ CONSTANTES ============

export const MESSAGE_TYPES = {
  TEXT: 'text' as const,
  IMAGE: 'image' as const,
  VOICE: 'voice' as const,
  SYSTEM: 'system' as const,
};

export const CONVERSATION_STATUS = {
  ACTIVE: 'active' as const,
  ARCHIVED: 'archived' as const,
  BLOCKED: 'blocked' as const,
};

export const REACTION_EMOJIS = [
  '‚ù§Ô∏è', 'üòÇ', 'üëç', 'üëé', 'üòÆ', 'üò¢', 'üò°', 'üî•', 'üíØ', 'üëè'
] as const;

export const MAX_MESSAGE_LENGTH = 4000;
export const MAX_MEDIA_SIZE = 10 * 1024 * 1024; // 10MB
export const MAX_VOICE_SIZE = 5 * 1024 * 1024; // 5MB

// ============ UTILITAIRES TYPE ============

export type MessageType = typeof MESSAGE_TYPES[keyof typeof MESSAGE_TYPES];
export type ConversationStatus = typeof CONVERSATION_STATUS[keyof typeof CONVERSATION_STATUS];
export type ReactionEmoji = typeof REACTION_EMOJIS[number];

// ============ GUARDS TYPE ============

export function isMessage(obj: any): obj is Message {
  return obj && typeof obj.id === 'string' && typeof obj.conversation_id === 'string';
}

export function isConversation(obj: any): obj is Conversation {
  return obj && typeof obj.id === 'string' && typeof obj.participant_1_id === 'string';
}

export function isValidMessageType(type: string): type is MessageType {
  return Object.values(MESSAGE_TYPES).includes(type as MessageType);
}

export function isValidConversationStatus(status: string): status is ConversationStatus {
  return Object.values(CONVERSATION_STATUS).includes(status as ConversationStatus);
}

jinxed@DESKTOP-L5861O7 MINGW64 /c/AffiniaV6 (main)
$
